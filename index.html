<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Album Artwork</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            cursor: none;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            z-index: 1000;
            text-align: center;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 10px;
            font-size: 16px;
        }

        .loading-progress {
            margin-top: 8px;
            font-size: 14px;
            opacity: 0.8;
        }

        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-size: 16px;
            line-height: 1.6;
        }
        
        /* è®¾ç½®é¢æ¿æ ·å¼ */
        .settings-button {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 1500;
            transition: all 0.3s ease;
            opacity: 0.3;
        }
        
        .settings-button:hover {
            opacity: 1;
            background: rgba(30, 30, 30, 0.8);
        }
        
        .settings-icon {
            width: 24px;
            height: 24px;
            fill: #fff;
        }
        
        .settings-panel {
            position: fixed;
            bottom: 65px;
            right: 15px;
            width: 320px;
            background: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            color: #fff;
            z-index: 1500;
            display: none;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        /* è®¾ç½®é¢æ¿æ»šåŠ¨æ¡æ ·å¼ */
        .settings-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .settings-panel::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 10px;
        }
        
        .settings-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            transition: background 0.3s ease;
        }
        
        .settings-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .settings-section {
            margin-bottom: 20px;
        }
        
        .settings-section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .settings-item {
            margin-bottom: 12px;
        }
        
        .settings-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .settings-range {
            width: 100%;
            margin-top: 5px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(60, 60, 60, 0.8);
            border-radius: 3px;
            outline: none;
        }
        
        .settings-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .settings-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .settings-range:focus {
            outline: none;
        }
        
        .settings-select {
            width: 100%;
            background: rgba(60, 60, 60, 0.8);
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 8px;
            font-size: 14px;
        }
        
        .settings-checkbox {
            margin-right: 8px;
        }
        
        .settings-value {
            display: inline-block;
            width: 40px;
            text-align: right;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .settings-color {
            width: 80px;
            height: 25px;
            padding: 0 5px;
            background: rgba(60, 60, 60, 0.8);
            color: #fff;
            border: none;
            border-radius: 4px;
        }
        
        .weight-container {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }
        
        .weight-container label {
            margin-right: 10px;
            font-size: 13px;
            opacity: 0.8;
        }
        
        .weight-slider {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(60, 60, 60, 0.8);
            border-radius: 3px;
            outline: none;
        }
        
        .weight-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .weight-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .settings-description {
            font-size: 12px;
            color: #999;
            margin-left: 10px;
            display: block;
            margin-top: 5px;
        }

        /* iframeæ’­æ”¾å™¨æ ·å¼ */
        .iframe-player {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            width: 70%;
            height: 70vh;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px 20px 0 0;
            z-index: 2000;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }

        .iframe-player.expanded {
            transform: translateX(-50%) translateY(0);
        }

        .iframe-player.collapsed {
            transform: translateX(-50%) translateY(calc(100% - 60px));
        }

        .iframe-topbar {
            height: 60px;
            background: rgba(30, 30, 30, 0.9);
            border-radius: 20px 20px 0 0;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .iframe-album-cover {
            width: 40px;
            height: 40px;
            border-radius: 50%; /* æ”¹ä¸ºå®Œå…¨åœ†å½¢ */
            margin-right: 15px;
            background: transparent; /* èƒŒæ™¯é€æ˜ */
            position: relative;
            overflow: hidden;
        }

        .iframe-album-cover canvas {
            width: 100%;
            height: 100%;
            border-radius: 50%; /* canvasä¹Ÿæ”¹ä¸ºåœ†å½¢ */
        }

        .iframe-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin-right: 15px;
        }

        .iframe-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .iframe-service {
            font-size: 12px;
            color: #999;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #jsi-cherry-container {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 30px;
            pointer-events: none;
            background-color: transparent;
        }

        /* æ¨±èŠ±é£˜è½åŠ¨ç”»æ ·å¼ */
        #jsi-cherry-container.container {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: transparent;
        }

        .iframe-controls {
            display: flex;
            gap: 8px;
        }

        .iframe-control-btn {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .iframe-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .iframe-control-btn.active {
            background: rgba(255, 255, 255, 0.3);
        }

        .iframe-content {
            flex: 1;
            position: relative;
            border-radius: 0 0 20px 20px;
            overflow: hidden;
            min-height: 0; /* ç¡®ä¿flexå­é¡¹å¯ä»¥æ”¶ç¼© */
            height: 90%;
        }

        .iframe-content iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
        }

        .iframe-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 16px;
            text-align: center;
        }

        .iframe-loading .loading-spinner {
            width: 32px;
            height: 32px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">æ­£åœ¨åŠ è½½ä¸“è¾‘å°é¢...</div>
        <div class="loading-progress" id="loading-progress"></div>
    </div>
    
    <!-- è®¾ç½®æŒ‰é’® -->
    <div class="settings-button" id="settings-button">
        <svg class="settings-icon" viewBox="0 0 24 24">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"></path>
        </svg>
    </div>
    
    <!-- è®¾ç½®é¢æ¿ -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-section">
            <div class="settings-section-title" data-text="layoutSettings">å¸ƒå±€è®¾ç½®</div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="rows">è¡Œæ•°</label>
                    <span class="settings-value" id="rows-value">6</span>
                </div>
                <input type="range" class="settings-range" id="rows-range" min="2" max="16" value="6">
            </div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="gapSize">é—´éš™å¤§å°</label>
                    <span class="settings-value" id="gap-value">0</span>
                </div>
                <input type="range" class="settings-range" id="gap-range" min="0" max="0.1" step="0.01" value="0">
            </div>
        </div>
        
        <div class="settings-section">
            <div class="settings-section-title" data-text="animationSettings">åŠ¨ç”»è®¾ç½®</div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="animationInterval">åŠ¨ç”»é—´éš” (æ¯«ç§’)</label>
                    <span class="settings-value" id="animation-interval-value">3000</span>
                </div>
                <input type="range" class="settings-range" id="animation-interval-range" min="1000" max="10000" step="500" value="3000">
            </div>
            <div class="settings-item">
                <label class="settings-label" data-text="animationWeights">åŠ¨ç”»ç±»å‹æƒé‡</label>
                <div class="weight-container">
                    <label data-text="flip">ç¿»è½¬:</label>
                    <input type="range" class="weight-slider" id="flip-weight" min="0" max="100" value="15">
                    <span class="settings-value" id="flip-weight-value">15</span>
                </div>
                <div class="weight-container">
                    <label data-text="drop">æ‰è½:</label>
                    <input type="range" class="weight-slider" id="drop-weight" min="0" max="100" value="15">
                    <span class="settings-value" id="drop-weight-value">15</span>
                </div>
                <div class="weight-container">
                    <label data-text="linkedDrop">è¿é”æ‰è½:</label>
                    <input type="range" class="weight-slider" id="linked-drop-weight" min="0" max="100" value="15">
                    <span class="settings-value" id="linked-drop-weight-value">15</span>
                </div>
                <div class="weight-container">
                    <label data-text="rollDrop">æ»šåŠ¨æ‰è½:</label>
                    <input type="range" class="weight-slider" id="roll-drop-weight" min="0" max="100" value="15">
                    <span class="settings-value" id="roll-drop-weight-value">15</span>
                </div>
                <div class="weight-container">
                    <label data-text="pinRotation">å›¾é’‰æ—‹è½¬:</label>
                    <input type="range" class="weight-slider" id="pin-rotation-weight" min="0" max="100" value="15">
                    <span class="settings-value" id="pin-rotation-weight-value">15</span>
                </div>
                <div class="weight-container">
                    <label data-text="rowRoll">è¡Œæ»šåŠ¨:</label>
                    <input type="range" class="weight-slider" id="row-roll-weight" min="0" max="100" value="12.5">
                    <span class="settings-value" id="row-roll-weight-value">12.5</span>
                </div>
                <div class="weight-container">
                    <label data-text="rowDrop">è¡Œæ‰è½:</label>
                    <input type="range" class="weight-slider" id="row-drop-weight" min="0" max="100" value="12.5">
                    <span class="settings-value" id="row-drop-weight-value">12.5</span>
                </div>
            </div>
        </div>
        
        <div class="settings-section">
            <div class="settings-section-title" data-text="appearanceSettings">å¤–è§‚è®¾ç½®</div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="backgroundColor">èƒŒæ™¯é¢œè‰²</label>
                    <input type="color" class="settings-color" id="background-color" value="#000000">
                </div>
            </div>
        </div>
        
        <div class="settings-section">
            <div class="settings-section-title" data-text="functionSettings">åŠŸèƒ½è®¾ç½®</div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="desktopMode">æ¡Œé¢æ¨¡å¼</label>
                    <input type="checkbox" id="desktop-mode-toggle">
                    <span class="settings-description" data-text="desktopModeDesc">å¯ç”¨ååªå“åº”ä¸‰è¿å‡»å·¦é”®ï¼Œé€‚åˆä½œä¸ºæ¡Œé¢å£çº¸</span>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="iframeMode">åœ¨å½“å‰é¡µé¢æ‰“å¼€éŸ³ä¹ç½‘ç«™</label>
                    <input type="checkbox" id="iframe-mode-toggle">
                    <span class="settings-description" data-text="iframeModeDesc">å¯ç”¨åç‚¹å‡»éŸ³ä¹é“¾æ¥å°†åœ¨å†…åµŒçª—å£ä¸­æ‰“å¼€ï¼Œè€Œä¸æ˜¯æ–°æ ‡ç­¾é¡µ</span>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="iframeMusicBrainzMode">åœ¨å½“å‰é¡µé¢æ‰“å¼€MusicBrainz</label>
                    <input type="checkbox" id="iframe-musicbrainz-toggle">
                    <span class="settings-description" data-text="iframeMusicBrainzModeDesc">å¯ç”¨åMusicBrainzé“¾æ¥å°†åœ¨å†…åµŒçª—å£ä¸­æ‰“å¼€</span>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-row">
                    <label class="settings-label" data-text="iframeListenBrainzMode">åœ¨å½“å‰é¡µé¢æ‰“å¼€ListenBrainz</label>
                    <input type="checkbox" id="iframe-listenbrainz-toggle">
                    <span class="settings-description" data-text="iframeListenBrainzModeDesc">å¯ç”¨åListenBrainzé“¾æ¥å°†åœ¨å†…åµŒçª—å£ä¸­æ‰“å¼€</span>
                </div>
            </div>
        </div>
        
        <div id="reset-container" style="text-align: center; margin-top: 20px;"></div>
    </div>

    <!-- iframeæ’­æ”¾å™¨ -->
    <div class="iframe-player" id="iframe-player">
        <div class="iframe-topbar">
            <div class="iframe-album-cover" id="iframe-album-cover">
                <canvas id="iframe-showcase-canvas"></canvas>
            </div>
            <div class="iframe-info">
                <div class="iframe-title" id="iframe-title">æœªé€‰æ‹©ä¸“è¾‘</div>
                <div class="iframe-service" id="iframe-service">éŸ³ä¹æœåŠ¡</div>
            </div>
            <div id="jsi-cherry-container" class="container"></div>
            <div class="iframe-controls">
                <button class="iframe-control-btn" id="iframe-pin-btn" title="å›ºå®š/å–æ¶ˆå›ºå®š">ğŸ“Œ</button>
                <button class="iframe-control-btn" id="iframe-expand-btn" title="å±•å¼€/æ”¶ç¼©">â¬‡ï¸</button>
                <button class="iframe-control-btn" id="iframe-close-btn" title="å…³é—­">âœ–ï¸</button>
            </div>
        </div>
        <div class="iframe-content">
            <div class="iframe-loading" id="iframe-loading">
                <div class="loading-spinner"></div>
                <div>æ­£åœ¨åŠ è½½éŸ³ä¹æœåŠ¡...</div>
            </div>
            <iframe id="iframe-embed" 
                    style="display: none; border-radius: 0 0 20px 20px;" 
                    frameBorder="0" 
                    allowfullscreen="" 
                    allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                    loading="lazy">
            </iframe>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <!-- jQuery CDN for cherry blossom animation -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- æ¨±èŠ±é£˜è½åŠ¨ç”»è„šæœ¬ -->
    <script>
        var RENDERER = {
            INIT_CHERRY_BLOSSOM_COUNT : 30,
            MAX_ADDING_INTERVAL : 10,
            WATCH_INTERVAL : 300,

            init : function(){
                this.isRunning = true;
                this.animationId = null;
                this.setParameters();
                this.reconstructMethods();
                this.setup();
                this.bindEvent();
                this.render();
            },
            setParameters : function(){
                this.$window = $(window);
                this.$container = $('#jsi-cherry-container');
                this.$canvas = $('<canvas />');
                this.context = this.$canvas.appendTo(this.$container).get(0).getContext('2d');
                this.cherries = [];
                this.watchIds = [];
            },
            reconstructMethods : function(){
                this.watchWindowSize = this.watchWindowSize.bind(this);
                this.jdugeToStopResize = this.jdugeToStopResize.bind(this);
                this.render = this.render.bind(this);
            },
            setup : function(){
                this.cherries.length = 0;
                this.watchIds.length = 0;
                this.width = this.$container.width() || 200;
                this.height = this.$container.height() || 30;
                this.$canvas.attr({width : this.width, height : this.height});
                this.maxAddingInterval = Math.round(this.MAX_ADDING_INTERVAL * 1000 / this.width);
                this.addingInterval = this.maxAddingInterval;
                this.createCherries();
            },
            createCherries : function(){
                // å¯¹äºå°å®¹å™¨ï¼Œå‡å°‘æ¨±èŠ±æ•°é‡
                var cherryCount = Math.max(3, Math.round(this.INIT_CHERRY_BLOSSOM_COUNT * this.width / 1000));
                for(var i = 0, length = cherryCount; i < length; i++){
                    this.cherries.push(new CHERRY_BLOSSOM(this, true));
                }
            },
            watchWindowSize : function(){
                this.clearTimer();
                this.tmpWidth = this.$window.width();
                this.tmpHeight = this.$window.height();
                this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL));
            },
            clearTimer : function(){
                while(this.watchIds.length > 0){
                    clearTimeout(this.watchIds.pop());
                }
            },
            jdugeToStopResize : function(){
                var width = this.$window.width(),
                    height = this.$window.height(),
                    stopped = (width == this.tmpWidth && height == this.tmpHeight);

                this.tmpWidth = width;
                this.tmpHeight = height;

                if(stopped){
                    this.setup();
                }
            },
            bindEvent : function(){
                this.$window.on('resize', this.watchWindowSize);
            },
            render : function(){
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥åœæ­¢æ¸²æŸ“
                if (!this.isRunning) {
                    return;
                }

                this.animationId = requestAnimationFrame(this.render);

                // æ£€æŸ¥contextæ˜¯å¦è¿˜å­˜åœ¨
                if (!this.context || !this.context.canvas || !this.context.canvas.parentNode) {
                    this.isRunning = false;
                    return;
                }

                this.context.clearRect(0, 0, this.width, this.height);

                this.cherries.sort(function(cherry1, cherry2){
                    return cherry1.z - cherry2.z;
                });
                for(var i = this.cherries.length - 1; i >= 0; i--){
                    if(!this.cherries[i].render(this.context)){
                        this.cherries.splice(i, 1);
                    }
                }
                if(--this.addingInterval == 0){
                    this.addingInterval = this.maxAddingInterval;
                    this.cherries.push(new CHERRY_BLOSSOM(this, false));
                }
            },

            stop : function(){
                this.isRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                this.clearTimer();
                this.cherries = [];
            }
        };

        var CHERRY_BLOSSOM = function(renderer, isRandom){
            this.renderer = renderer;
            this.init(isRandom);
        };

        CHERRY_BLOSSOM.prototype = {
            FOCUS_POSITION : 300,
            FAR_LIMIT : 600,
            MAX_RIPPLE_COUNT : 100,
            RIPPLE_RADIUS : 100,
            SURFACE_RATE : 0.5,
            SINK_OFFSET : 20,

            init : function(isRandom){
                this.x = this.getRandomValue(-this.renderer.width, this.renderer.width);
                this.y = isRandom ? this.getRandomValue(0, this.renderer.height) : this.renderer.height * 1.5;
                this.z = this.getRandomValue(0, this.FAR_LIMIT);
                this.vx = this.getRandomValue(-1, 1); // å‡å°æ°´å¹³é€Ÿåº¦
                this.vy = -1; // å‡å°å‚ç›´é€Ÿåº¦
                this.theta = this.getRandomValue(0, Math.PI * 2);
                this.phi = this.getRandomValue(0, Math.PI * 2);
                this.psi = 0;
                this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300);
                this.opacity = 0;
                this.endTheta = false;
                this.endPhi = false;
                this.rippleCount = 0;

                var axis = this.getAxis(),
                    theta = this.theta + Math.ceil(-(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy) * Math.PI / 500;
                theta %= Math.PI * 2;

                // ç¼©å°æ¨±èŠ±å°ºå¯¸ä»¥é€‚åº”å°å®¹å™¨
                var scale = Math.min(1, this.renderer.width / 200);
                this.offsetY = 20 * scale * ((theta <= Math.PI / 2 || theta >= Math.PI * 3 / 2) ? -1 : 1);
                this.thresholdY = this.renderer.height / 2 + this.renderer.height * this.SURFACE_RATE * axis.rate;
                this.entityColor = this.renderer.context.createRadialGradient(0, 20 * scale, 0, 0, 20 * scale, 40 * scale);
                this.entityColor.addColorStop(0, 'hsl(330, 70%, ' + 50 * (0.3 + axis.rate) + '%)');
                this.entityColor.addColorStop(0.05, 'hsl(330, 40%,' + 55 * (0.3 + axis.rate) + '%)');
                this.entityColor.addColorStop(1, 'hsl(330, 20%, ' + 70 * (0.3 + axis.rate) + '%)');
                this.shadowColor = this.renderer.context.createRadialGradient(0, 20 * scale, 0, 0, 20 * scale, 40 * scale);
                this.shadowColor.addColorStop(0, 'hsl(330, 40%, ' + 30 * (0.3 + axis.rate) + '%)');
                this.shadowColor.addColorStop(0.05, 'hsl(330, 40%,' + 30 * (0.3 + axis.rate) + '%)');
                this.shadowColor.addColorStop(1, 'hsl(330, 20%, ' + 40 * (0.3 + axis.rate) + '%)');
            },
            getRandomValue : function(min, max){
                return min + (max - min) * Math.random();
            },
            getAxis : function(){
                var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION),
                    x = this.renderer.width / 2 + this.x * rate,
                    y = this.renderer.height / 2 - this.y * rate;
                return {rate : rate, x : x, y : y};
            },
            renderCherry : function(context, axis){
                // æ ¹æ®å®¹å™¨å¤§å°è°ƒæ•´æ¨±èŠ±å°ºå¯¸
                var scale = Math.min(1, this.renderer.width / 200);
                var size = 20 * scale;

                context.beginPath();
                context.moveTo(0, size);
                context.bezierCurveTo(-size * 1.5, size * 0.5, -size * 0.25, -size * 1.5, 0, -size * 0.5);
                context.bezierCurveTo(size * 0.25, -size * 1.5, size * 1.5, size * 0.5, 0, size);
                context.fill();

                for(var i = -2; i < 2; i++){
                    context.beginPath();
                    context.moveTo(0, size);
                    context.quadraticCurveTo(i * 6 * scale, 5 * scale, i * 2 * scale, -12 * scale + Math.abs(i) * scale);
                    context.stroke();
                }
            },
            render : function(context){
                var axis = this.getAxis();

                if(axis.y == this.thresholdY && this.rippleCount < this.MAX_RIPPLE_COUNT){
                    context.save();
                    context.lineWidth = 2;
                    context.strokeStyle = 'hsla(0, 0%, 100%, ' + (this.MAX_RIPPLE_COUNT - this.rippleCount) / this.MAX_RIPPLE_COUNT + ')';
                    context.translate(axis.x + this.offsetY * axis.rate * (this.theta <= Math.PI ? -1 : 1), axis.y);
                    context.scale(1, 0.3);
                    context.beginPath();
                    context.arc(0, 0, this.rippleCount / this.MAX_RIPPLE_COUNT * this.RIPPLE_RADIUS * axis.rate, 0, Math.PI * 2, false);
                    context.stroke();
                    context.restore();
                    this.rippleCount++;
                }
                if(axis.y < this.thresholdY || (!this.endTheta || !this.endPhi)){
                    if(this.y <= 0){
                        this.opacity = Math.min(this.opacity + 0.01, 1);
                    }
                    context.save();
                    context.globalAlpha = this.opacity;
                    context.fillStyle = this.shadowColor;
                    context.strokeStyle = 'hsl(330, 30%,' + 40 * (0.3 + axis.rate) + '%)';
                    context.translate(axis.x, Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y));
                    context.rotate(Math.PI - this.theta);
                    context.scale(axis.rate * -Math.sin(this.phi), axis.rate);
                    context.translate(0, this.offsetY);
                    this.renderCherry(context, axis);
                    context.restore();
                }
                context.save();
                context.fillStyle = this.entityColor;
                context.strokeStyle = 'hsl(330, 40%,' + 70 * (0.3 + axis.rate) + '%)';
                context.translate(axis.x, axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate));
                context.rotate(this.theta);
                context.scale(axis.rate * Math.sin(this.phi), axis.rate);
                context.translate(0, this.offsetY);
                this.renderCherry(context, axis);
                context.restore();

                if(this.y <= -this.renderer.height / 4){
                    if(!this.endTheta){
                        for(var theta = Math.PI / 2, end = Math.PI * 3 / 2; theta <= end; theta += Math.PI){
                            if(this.theta < theta && this.theta + Math.PI / 200 > theta){
                                this.theta = theta;
                                this.endTheta = true;
                                break;
                            }
                        }
                    }
                    if(!this.endPhi){
                        for(var phi = Math.PI / 8, end = Math.PI * 7 / 8; phi <= end; phi += Math.PI * 3 / 4){
                            if(this.phi < phi && this.phi + Math.PI / 200 > phi){
                                this.phi = Math.PI / 8;
                                this.endPhi = true;
                                break;
                            }
                        }
                    }
                }
                if(!this.endTheta){
                    if(axis.y == this.thresholdY){
                        this.theta += Math.PI / 200 * ((this.theta < Math.PI / 2 || (this.theta >= Math.PI && this.theta < Math.PI * 3 / 2)) ? 1 : -1);
                    }else{
                        this.theta += Math.PI / 500;
                    }
                    this.theta %= Math.PI * 2;
                }
                if(this.endPhi){
                    if(this.rippleCount == this.MAX_RIPPLE_COUNT){
                        this.psi += this.dpsi;
                        this.psi %= Math.PI * 2;
                    }
                }else{
                    this.phi += Math.PI / ((axis.y == this.thresholdY) ? 200 : 500);
                    this.phi %= Math.PI;
                }
                if(this.y <= -this.renderer.height * this.SURFACE_RATE){
                    this.x += 2;
                    this.y = -this.renderer.height * this.SURFACE_RATE;
                }else{
                    this.x += this.vx;
                    this.y += this.vy;
                }
                return this.z > -this.FOCUS_POSITION && this.z < this.FAR_LIMIT && this.x < this.renderer.width * 1.5;
            }
        };
    </script>

    <script>
        class ThreeJSScreensaver {
            constructor() {
                this.container = document.getElementById('container');
                this.loading = document.getElementById('loading');
                this.loadingText = document.getElementById('loading-text');
                this.loadingProgress = document.getElementById('loading-progress');
                this.settingsButton = document.getElementById('settings-button');
                this.settingsPanel = document.getElementById('settings-panel');
                
                // ä¸‰è¿å‡»æ£€æµ‹ç›¸å…³å˜é‡
                this.clickCount = 0;
                this.clickTimer = null;
                this.clickTimeout = 500; // è¿å‡»é—´éš”æ—¶é—´(æ¯«ç§’)
                this.albums = [];
                this.albumUrls = {};
                this.config = null;
                
                // è®¾ç½®é¢æ¿çŠ¶æ€
                this.isPanelVisible = false;

                // å¤šè¯­è¨€æ”¯æŒ
                this.language = this.detectLanguage();
                this.texts = this.getTexts();

                // MusicBrainz ç›¸å…³
                this.musicBrainzCollectionIds = this.parseCollectionIdsFromUrl();
                this.coverCache = new Map(); // å°é¢ç¼“å­˜
                this.albumsCache = []; // ä¸“è¾‘åˆ—è¡¨ç¼“å­˜
                this.albumsTimestamp = 0; // ä¸“è¾‘åˆ—è¡¨ç¼“å­˜æ—¶é—´æˆ³
                this.externalLinksCache = new Map(); // å¤–éƒ¨é“¾æ¥ç¼“å­˜
                this.lastApiCallTime = 0; // ç”¨äºAPIè°ƒç”¨èŠ‚æµ
                // this.cacheExpiry = 24 * 60 * 60 * 1000; // 24å°æ—¶è¿‡æœŸ - å·²ç§»é™¤è¿‡æœŸæ—¶é—´ï¼Œç¼“å­˜æ°¸ä¹…æœ‰æ•ˆ

                // Three.js ç›¸å…³
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.covers = [];
                this.animationMixer = null;
                this.clock = new THREE.Clock();

                // ç½‘æ ¼å‚æ•°
                this.gridRows = 6; // è¡Œæ•°ï¼Œå¯ç”±ç”¨æˆ·è‡ªå®šä¹‰
                this.coverSize = 1; // åŸºç¡€å°é¢å¤§å°ï¼Œä¼šæ ¹æ®è¡Œæ•°è‡ªåŠ¨è®¡ç®—
                this.gap = 0; // é—´éš™å¤§å°

                // å°é¢åˆ†é…ç›¸å…³
                this.usedAlbums = []; // å·²ä½¿ç”¨çš„ä¸“è¾‘å°é¢ç´¢å¼•
                this.isInitializing = true; // æ˜¯å¦æ­£åœ¨åˆå§‹åŒ–

                // åŠ¨ç”»ç›¸å…³
                this.animationInterval = null;
                this.activeAnimations = [];
                this.animationIntervalTime = 3000; // é»˜è®¤åŠ¨ç”»é—´éš”æ—¶é—´
                this.animationWeights = {
                    flip: 15,
                    drop: 15,
                    linkedDrop: 15,
                    rollDrop: 15,
                    pinRotation: 15,
                    rowRollDrop: 12.5,
                    rowDrop: 12.5
                };
                
                // 3Då±•ç¤ºå°ç›¸å…³å±æ€§
                this.showcaseScene = null;
                this.showcaseCamera = null;
                this.showcaseRenderer = null;
                this.showcaseCover = null;
                this.showcaseStand = null;
                this.showcaseLights = [];
                this.showcaseAnimationId = null;
                this.mousePosition = { x: 0, y: 0 };
                this.showcaseActive = false;
                
                // å…¨å±é¼ æ ‡è¿½è¸ªç›¸å…³å±æ€§
                this.showcaseMouseMoveHandler = null;
                this.showcaseMouseIdleHandler = null;
                this.mouseIdleTimer = null;
                
                // iframeæ’­æ”¾å™¨ç›¸å…³å±æ€§
                this.iframeModeEnabled = false;
                this.iframeMusicBrainzModeEnabled = false;
                this.iframeListenBrainzModeEnabled = false;
                this.iframePlayer = document.getElementById('iframe-player');
                this.iframeEmbed = document.getElementById('iframe-embed');
                this.iframeLoading = document.getElementById('iframe-loading');
                this.iframeTitle = document.getElementById('iframe-title');
                this.iframeService = document.getElementById('iframe-service');
                this.iframeAlbumCover = document.getElementById('iframe-album-cover');
                this.iframePinBtn = document.getElementById('iframe-pin-btn');
                this.iframeExpandBtn = document.getElementById('iframe-expand-btn');
                this.iframeCloseBtn = document.getElementById('iframe-close-btn');
                this.iframeShowcaseCanvas = document.getElementById('iframe-showcase-canvas');
                
                // iframeçŠ¶æ€
                this.isIframePinned = false;
                this.isIframeExpanded = false;
                this.iframeMouseLeaveTimer = null;
                this.currentIframeUrl = null;
                this.currentAlbumData = null;
                
                // iframe 3Då±•ç¤ºå°
                this.iframeShowcaseScene = null;
                this.iframeShowcaseCamera = null;
                this.iframeShowcaseRenderer = null;
                this.iframeShowcaseCover = null;
                this.iframeShowcaseAnimationId = null;
                

                
                // ä»æœ¬åœ°å­˜å‚¨åŠ è½½è®¾ç½®
                this.loadSettings();

                // æ›´æ–°UIæ–‡æœ¬ä¸ºå¯¹åº”è¯­è¨€
                this.updateUITexts();

                this.init();
            }

            // æ›´æ–°UIä¸­çš„æ–‡æœ¬ä¸ºå¯¹åº”è¯­è¨€
            updateUITexts() {
                // æ›´æ–°æ‰€æœ‰å¸¦æœ‰ data-text å±æ€§çš„å…ƒç´ 
                const elementsWithText = document.querySelectorAll('[data-text]');
                elementsWithText.forEach(element => {
                    const textKey = element.getAttribute('data-text');
                    if (this.texts[textKey]) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ label å…ƒç´ ä¸”åŒ…å«å†’å·ï¼Œå¦‚æœæ˜¯åˆ™ä¿ç•™å†’å·
                        if (element.tagName.toLowerCase() === 'label' && element.textContent.includes(':')) {
                            element.textContent = this.texts[textKey] + ':';
                        } else {
                            element.textContent = this.texts[textKey];
                        }
                    }
                });
            }

            // æ£€æµ‹ç”¨æˆ·è¯­è¨€
            detectLanguage() {
                // æ£€æŸ¥æµè§ˆå™¨è¯­è¨€è®¾ç½®
                const browserLang = navigator.language || navigator.userLanguage;

                // å¦‚æœæ˜¯ä¸­æ–‡ç›¸å…³çš„è¯­è¨€ä»£ç ï¼Œä½¿ç”¨ä¸­æ–‡
                if (browserLang.startsWith('zh')) {
                    return 'zh';
                }

                // é»˜è®¤ä½¿ç”¨è‹±æ–‡
                return 'en';
            }

            // è·å–å¤šè¯­è¨€æ–‡æœ¬
            getTexts() {
                const texts = {
                    zh: {
                        loading: 'æ­£åœ¨åŠ è½½ä¸“è¾‘å°é¢...',
                        loadingFromCollection: 'æ­£åœ¨ä» {count} ä¸ª MusicBrainz æ”¶è—æ è·å–ä¸“è¾‘...',
                        loadingCollection: 'æ­£åœ¨è·å–æ”¶è—æ  {current}/{total}...',
                        loadingCovers: 'æ­£åœ¨åŠ è½½ä¸“è¾‘å°é¢...',
                        loadingProgress: '({current}/{total})',
                        loadComplete: 'åŠ è½½å®Œæˆï¼',
                        errorNetwork: 'åŠ è½½ä¸“è¾‘å°é¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥',
                        errorCollection: 'æ— æ³•ä»æŒ‡å®šçš„ MusicBrainz æ”¶è—æ è·å–ä¸“è¾‘ï¼Œè¯·æ£€æŸ¥æ”¶è—æ  ID æ˜¯å¦æ­£ç¡®ï¼š{ids}',
                        helpEsc: 'æŒ‰ESCé”®é€€å‡ºå±ä¿',
                        loadingBackup: 'æ­£åœ¨åŠ è½½æœ¬åœ°ä¸“è¾‘å°é¢...',
                        usingLocalMode: 'ä½¿ç”¨æœ¬åœ°æ¨¡å¼',
                        noCoversFound: 'æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„ä¸“è¾‘å°é¢ï¼Œè¯·ç¡®ä¿ cover ç›®å½•ä¸­æœ‰å›¾ç‰‡æ–‡ä»¶',
                        openedLinks: 'å·²æ‰“å¼€: {links}',
                        noExternalLinks: 'å·²æ‰“å¼€MusicBrainz (æ— æ³•è·å–å…¶ä»–é“¾æ¥)',
                        externalLinksFor: 'ä¸“è¾‘å¤–éƒ¨é“¾æ¥',
                        noLinksFound: 'æ²¡æœ‰æ‰¾åˆ°å¤–éƒ¨é“¾æ¥',
                        loadingLinks: 'æ­£åœ¨åŠ è½½å¤–éƒ¨é“¾æ¥...',
                        externalLinksReady: 'å¤–éƒ¨é“¾æ¥å·²å°±ç»ª',
                        linkCopied: '{service}é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿',
                        scanningDirectory: 'æ­£åœ¨æ‰«æ cover ç›®å½•...',
                        // è®¾ç½®é¢æ¿æ–‡æœ¬
                        layoutSettings: 'å¸ƒå±€è®¾ç½®',
                        rows: 'è¡Œæ•°',
                        gapSize: 'é—´éš™å¤§å°',
                        animationSettings: 'åŠ¨ç”»è®¾ç½®',
                        animationInterval: 'åŠ¨ç”»é—´éš” (æ¯«ç§’)',
                        animationWeights: 'åŠ¨ç”»ç±»å‹æƒé‡',
                        flip: 'ç¿»è½¬',
                        drop: 'æ‰è½',
                        linkedDrop: 'è¿é”æ‰è½',
                        rollDrop: 'æ»šåŠ¨æ‰è½',
                        pinRotation: 'å›¾é’‰æ—‹è½¬',
                        rowRoll: 'è¡Œæ»šåŠ¨',
                        rowDrop: 'è¡Œæ‰è½',
                        appearanceSettings: 'å¤–è§‚è®¾ç½®',
                        backgroundColor: 'èƒŒæ™¯é¢œè‰²',
                        functionSettings: 'åŠŸèƒ½è®¾ç½®',
                        desktopMode: 'æ¡Œé¢æ¨¡å¼',
                        desktopModeDesc: 'å¯ç”¨ååªå“åº”ä¸‰è¿å‡»å·¦é”®ï¼Œé€‚åˆä½œä¸ºæ¡Œé¢å£çº¸',
                        resetAllSettings: 'é‡ç½®æ‰€æœ‰è®¾ç½®',
                        clearCache: 'æ¸…é™¤ç¼“å­˜',
                        settingsSaved: 'è®¾ç½®å·²ä¿å­˜',
                        settingsSaveFailed: 'è®¾ç½®ä¿å­˜å¤±è´¥',
                        desktopModeEnabled: 'å·²å¯ç”¨æ¡Œé¢æ¨¡å¼ï¼Œåªå“åº”ä¸‰è¿å‡»å·¦é”®',
                        desktopModeDisabled: 'å·²ç¦ç”¨æ¡Œé¢æ¨¡å¼ï¼Œæ­£å¸¸å“åº”ç‚¹å‡»äº‹ä»¶',
                        allSettingsReset: 'æ‰€æœ‰è®¾ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼',
                        allCacheCleared: 'æ‰€æœ‰ç¼“å­˜å·²æ¸…é™¤ï¼Œé¡µé¢å°†åœ¨3ç§’ååˆ·æ–°'
                    },
                    en: {
                        loading: 'Loading album covers...',
                        loadingFromCollection: 'Loading albums from {count} MusicBrainz collections...',
                        loadingCollection: 'Loading collection {current}/{total}...',
                        loadingCovers: 'Loading album covers...',
                        loadingProgress: '({current}/{total})',
                        loadComplete: 'Loading complete!',
                        errorNetwork: 'Failed to load album covers, please check your network connection',
                        errorCollection: 'Unable to load albums from specified MusicBrainz collections, please check collection IDs: {ids}',
                        helpEsc: 'Press ESC to exit screensaver',
                        loadingBackup: 'Loading local album covers...',
                        usingLocalMode: 'Using local mode',
                        noCoversFound: 'No album covers found, please make sure there are image files in the cover directory',
                        openedLinks: 'Opened: {links}',
                        noExternalLinks: 'Opened MusicBrainz (could not get other links)',
                        externalLinksFor: 'External Links for Album',
                        noLinksFound: 'No external links found',
                        loadingLinks: 'Loading external links...',
                        externalLinksReady: 'External links ready',
                        linkCopied: '{service} link copied to clipboard',
                        scanningDirectory: 'Scanning cover directory...',
                        // è®¾ç½®é¢æ¿æ–‡æœ¬
                        layoutSettings: 'Layout Settings',
                        rows: 'Rows',
                        gapSize: 'Gap Size',
                        animationSettings: 'Animation Settings',
                        animationInterval: 'Animation Interval (ms)',
                        animationWeights: 'Animation Type Weights',
                        flip: 'Flip',
                        drop: 'Drop',
                        linkedDrop: 'Linked Drop',
                        rollDrop: 'Roll Drop',
                        pinRotation: 'Pin Rotation',
                        rowRoll: 'Row Roll',
                        rowDrop: 'Row Drop',
                        appearanceSettings: 'Appearance Settings',
                        backgroundColor: 'Background Color',
                        functionSettings: 'Function Settings',
                        desktopMode: 'Desktop Mode',
                        desktopModeDesc: 'When enabled, only responds to triple-click, suitable for desktop wallpaper',
                        resetAllSettings: 'Reset All Settings',
                        clearCache: 'Clear Cache',
                        settingsSaved: 'Settings saved',
                        settingsSaveFailed: 'Failed to save settings',
                        desktopModeEnabled: 'Desktop mode enabled, only responds to triple-click',
                        desktopModeDisabled: 'Desktop mode disabled, responds to normal clicks',
                        allSettingsReset: 'All settings have been reset to default values',
                        allCacheCleared: 'All cache cleared, page will refresh in 3 seconds'
                    }
                };

                return texts[this.language];
            }

            // æ ¼å¼åŒ–æ–‡æœ¬ï¼ˆæ›¿æ¢å ä½ç¬¦ï¼‰
            formatText(key, params = {}) {
                let text = this.texts[key];
                for (const [param, value] of Object.entries(params)) {
                    text = text.replace(`{${param}}`, value);
                }
                return text;
            }

            // ä»URLå‚æ•°ä¸­è§£ææ”¶è—å¤¹ID
            parseCollectionIdsFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);

                // æ£€æŸ¥æ˜¯å¦æŒ‡å®šäº†localå‚æ•°
                if (urlParams.has('local')) {
                    console.log('ä½¿ç”¨æœ¬åœ°æ¨¡å¼');
                    return [];
                }

                const ids = urlParams.getAll('id'); // è·å–æ‰€æœ‰idå‚æ•°

                if (ids.length > 0) {
                    console.log(`ä»URLå‚æ•°è·å–åˆ° ${ids.length} ä¸ªæ”¶è—å¤¹ID:`, ids);
                    return ids;
                } else {
                    // å¦‚æœæ²¡æœ‰URLå‚æ•°ï¼Œä½¿ç”¨é»˜è®¤æ”¶è—å¤¹ID
                    const defaultId = '8ac56a60-c667-4603-817e-793f0d2600b8';
                    console.log('ä½¿ç”¨é»˜è®¤æ”¶è—å¤¹ID:', defaultId);
                    return [defaultId];
                }
            }

            async init() {
                try {
                    // åˆå§‹åŒ–æ¡Œé¢æ¨¡å¼å˜é‡ï¼ˆé»˜è®¤å…³é—­ï¼‰
                    if (this.desktopMode === undefined) {
                        this.desktopMode = false;
                    }
                    
                    // åˆå§‹åŒ–åŠ è½½æ¶ˆæ¯
                    this.updateLoadingMessage(this.texts.loading);

                    // await this.loadConfig();
                    await this.loadCoverCache();
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°æ¨¡å¼
                    const isLocalMode = window.location.search.includes('local=true');
                    
                    if (isLocalMode) {
                        // æœ¬åœ°æ¨¡å¼ï¼šç›´æ¥æ‰«ææœ¬åœ°ç›®å½•
                        console.log('ä½¿ç”¨æœ¬åœ°æ¨¡å¼ï¼Œæ‰«ææœ¬åœ°å›¾ç‰‡ç›®å½•');
                        this.updateLoadingMessage('ä½¿ç”¨æœ¬åœ°æ¨¡å¼ï¼Œæ‰«ææœ¬åœ°å›¾ç‰‡...');
                        await this.loadAlbumsFromBackup();
                    } else if (this.albumsCache.length > 0) {
                        // æœ‰ç¼“å­˜ï¼šä½¿ç”¨ç¼“å­˜
                        console.log('ä½¿ç”¨ç¼“å­˜çš„ä¸“è¾‘åˆ—è¡¨');
                        this.updateLoadingMessage(this.texts.loadingCovers);
                        
                        // ä½¿ç”¨ç¼“å­˜çš„ä¸“è¾‘åˆ—è¡¨
                        await this.loadAlbumsFromCache();
                        
                        // åœ¨åå°è·å–æœ€æ–°çš„ä¸“è¾‘åˆ—è¡¨å¹¶æ¯”å¯¹
                        this.checkForAlbumsUpdate();
                    } else {
                        // æ— ç¼“å­˜ä¸”éæœ¬åœ°æ¨¡å¼ï¼šè·å–MusicBrainzæ•°æ®
                        console.log('æ²¡æœ‰ç¼“å­˜çš„ä¸“è¾‘åˆ—è¡¨ï¼Œä» MusicBrainz è·å–');
                        // æœ€å¤šå°è¯•3æ¬¡
                        let retryCount = 0;
                        const maxRetries = 3;
                        let success = false;
                        
                        while (retryCount < maxRetries && !success) {
                            try {
                                await this.loadAlbumsFromMusicBrainz();
                                success = true;
                            } catch (error) {
                                retryCount++;
                                console.warn(`ä» MusicBrainz è·å–ä¸“è¾‘å¤±è´¥ (å°è¯• ${retryCount}/${maxRetries})`, error);
                                if (retryCount < maxRetries) {
                                    // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                                    console.log(`é‡è¯•è·å– MusicBrainz æ•°æ® (${retryCount}/${maxRetries})...`);
                                }
                            }
                        }
                    }

                    // å¦‚æœä¸“è¾‘åˆ—è¡¨ä»ä¸ºç©ºï¼Œå°è¯•ä½¿ç”¨æœ¬åœ°å¤‡ä»½
                    if (this.albums.length === 0) {
                        console.warn('ä¸“è¾‘åˆ—è¡¨ä¸ºç©ºï¼Œå°è¯•ä½¿ç”¨æœ¬åœ°å¤‡ä»½');
                        await this.loadAlbumsFromBackup();
                    }

                    this.updateLoadingMessage(this.texts.loadComplete);

                    this.initThreeJS();
                    this.createGrid();
                    this.isInitializing = false; // åˆå§‹åŒ–å®Œæˆ
                    this.hideLoading();
                    this.startAnimations();
                    this.bindEvents();
                    this.initIframePlayer(); // åˆå§‹åŒ–iframeæ’­æ”¾å™¨
                    this.animate();
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±è´¥:', error);

                    // åªæœ‰åœ¨ç”¨æˆ·æ˜ç¡®è¦æ±‚ä½¿ç”¨æœ¬åœ°æ¨¡å¼æ—¶æ‰ä½¿ç”¨æœ¬åœ°æ¨¡å¼ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
                    if (window.location.search.includes('local=true')) {
                        try {
                            console.warn('ç”¨æˆ·æŒ‡å®šä½¿ç”¨æœ¬åœ°æ¨¡å¼ï¼Œå°è¯•ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ');
                            await this.loadAlbumsFromBackup();
                            
                            this.updateLoadingMessage(this.texts.loadComplete);
                            this.initThreeJS();
                            this.createGrid();
                            this.isInitializing = false;
                            this.hideLoading();
                            this.startAnimations();
                            this.bindEvents();
                            this.initIframePlayer(); // åˆå§‹åŒ–iframeæ’­æ”¾å™¨
                            this.animate();
                        } catch (backupError) {
                            console.error('æœ¬åœ°æ¨¡å¼ä¹Ÿå¤±è´¥:', backupError);
                            this.showError(this.texts.errorNetwork);
                        }
                    } else {
                        // å¦‚æœæŒ‡å®šäº† MusicBrainz ID ä½†è·å–å¤±è´¥ï¼Œæ˜¾ç¤ºå…·ä½“é”™è¯¯ä¿¡æ¯
                        if (this.musicBrainzCollectionIds.length > 0) {
                            this.showError(this.formatText('errorCollection', {
                                ids: this.musicBrainzCollectionIds.join(', ')
                            }));
                        } else {
                            this.showError(this.texts.errorNetwork);
                        }
                    }
                }
            }

            async loadConfig() {
                try {
                    const response = await fetch('./config.json?t=' + Date.now());
                    if (response.ok) {
                        this.config = await response.json();
                        console.log('âœ… é…ç½®åŠ è½½æˆåŠŸ');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('âŒ é…ç½®åŠ è½½å¤±è´¥:', error.message);
                    console.warn('ä½¿ç”¨é»˜è®¤é…ç½®');
                    this.config = {
                        screensaver: {
                            layout: {
                                coverSize: { min: 120, max: 300, default: 200 },
                                columns: { min: 3, max: 12, preferred: 12 },
                                layoutMode: "horizontal"
                            },
                            animation: {
                                enabled: true,
                                interval: { min: 3000, max: 8000 },
                                types: {
                                    flip: { enabled: true, weight: 40 },
                                    drop: { enabled: true, weight: 35 },
                                    linkedDrop: { enabled: true, weight: 25 }
                                }
                            }
                        }
                    };
                }
            }

            // åŠ è½½ç¼“å­˜
            async loadCoverCache() {
                try {
                    // åŠ è½½å°é¢ç¼“å­˜
                    const cached = localStorage.getItem('musicbrainz_cover_cache');
                    if (cached) {
                        const cacheData = JSON.parse(cached);
                        // ä¸å†æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸï¼Œç›´æ¥åŠ è½½æ‰€æœ‰ç¼“å­˜
                        for (const [key, value] of Object.entries(cacheData)) {
                            this.coverCache.set(key, value);
                        }
                        console.log(`âœ… åŠ è½½äº† ${this.coverCache.size} ä¸ªç¼“å­˜çš„å°é¢`);
                    }
                    
                    // åŠ è½½ä¸“è¾‘åˆ—è¡¨ç¼“å­˜
                    const cachedAlbums = localStorage.getItem('musicbrainz_albums_cache');
                    if (cachedAlbums) {
                        const albumsData = JSON.parse(cachedAlbums);
                        this.albumsCache = albumsData.albums || [];
                        this.albumsTimestamp = albumsData.timestamp || 0;
                        console.log(`âœ… åŠ è½½äº†ç¼“å­˜çš„ä¸“è¾‘åˆ—è¡¨ï¼Œå…± ${this.albumsCache.length} ä¸ªä¸“è¾‘`);
                    }
                } catch (error) {
                    console.warn('åŠ è½½ç¼“å­˜å¤±è´¥:', error);
                }
            }

            // ä¿å­˜ç¼“å­˜
            saveCoverCache() {
                try {
                    // ä¿å­˜å°é¢ç¼“å­˜
                    const cacheData = {};
                    for (const [key, value] of this.coverCache.entries()) {
                        cacheData[key] = value;
                    }
                    localStorage.setItem('musicbrainz_cover_cache', JSON.stringify(cacheData));
                    console.log('âœ… å°é¢ç¼“å­˜å·²ä¿å­˜');
                } catch (error) {
                    console.warn('ä¿å­˜å°é¢ç¼“å­˜å¤±è´¥:', error);
                }
            }
            
            // ä¿å­˜ä¸“è¾‘åˆ—è¡¨ç¼“å­˜
            saveAlbumsCache(albums) {
                try {
                    const albumsData = {
                        albums: albums,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('musicbrainz_albums_cache', JSON.stringify(albumsData));
                    this.albumsCache = albums;
                    this.albumsTimestamp = albumsData.timestamp;
                    console.log(`âœ… ä¸“è¾‘åˆ—è¡¨ç¼“å­˜å·²ä¿å­˜ï¼Œå…± ${albums.length} ä¸ªä¸“è¾‘`);
                } catch (error) {
                    console.warn('ä¿å­˜ä¸“è¾‘åˆ—è¡¨ç¼“å­˜å¤±è´¥:', error);
                }
            }

            // ä»ç¼“å­˜åŠ è½½ä¸“è¾‘åˆ—è¡¨
            async loadAlbumsFromCache() {
                try {
                    console.log('ä»ç¼“å­˜åŠ è½½ä¸“è¾‘åˆ—è¡¨...');
                    
                    // æ¸…ç©ºå½“å‰ä¸“è¾‘åˆ—è¡¨
                    this.albums = [];
                    this.albumUrls = {};
                    
                    // åŠ è½½æ¯ä¸ªä¸“è¾‘çš„å°é¢
                    let loadedCount = 0;
                    const totalCount = this.albumsCache.length;
                    
                    // å¹¶å‘åŠ è½½å°é¢ï¼Œæ¯æ‰¹æ¬¡20ä¸ª
                    const batchSize = 20;
                    for (let i = 0; i < totalCount; i += batchSize) {
                        const batch = this.albumsCache.slice(i, i + batchSize);
                        const promises = batch.map(async (release) => {
                            try {
                                const coverUrl = await this.getCoverArt(release.id);
                                // ç›´æ¥æ·»åŠ åˆ°åˆ—è¡¨ï¼Œä¸æ£€æŸ¥æ˜¯å¦ä¸ºç©º
                                this.albums.push(coverUrl);
                                this.albumUrls[coverUrl] = `https://musicbrainz.org/release/${release.id}`;
                                loadedCount++;
                                return 1;
                            } catch (error) {
                                console.warn(`æ— æ³•åŠ è½½ç¼“å­˜çš„ä¸“è¾‘å°é¢: ${release.title || release.id}`, error);
                                return 0;
                            }
                        });
                        
                        // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                        await Promise.all(promises);
                        
                        // æ›´æ–°åŠ è½½è¿›åº¦
                        this.updateLoadingMessage(
                            this.texts.loadingCovers,
                            this.formatText('loadingProgress', {
                                current: loadedCount,
                                total: totalCount
                            })
                        );
                    }
                    
                    // ä¸å†æ£€æŸ¥ä¸“è¾‘æ•°é‡æ˜¯å¦ä¸ºé›¶ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨æ€»æ˜¯æ·»åŠ å°é¢åˆ°åˆ—è¡¨ä¸­
                    
                    console.log(`âœ… ä»ç¼“å­˜æˆåŠŸåŠ è½½ ${this.albums.length} å¼ ä¸“è¾‘å°é¢`);
                    
                } catch (error) {
                    console.error('ä»ç¼“å­˜åŠ è½½ä¸“è¾‘å¤±è´¥:', error);
                    // å¦‚æœä»ç¼“å­˜åŠ è½½å¤±è´¥ï¼Œå°è¯•ä» MusicBrainz è·å–
                    await this.loadAlbumsFromMusicBrainz();
                }
            }
            
            // åœ¨åå°æ£€æŸ¥ä¸“è¾‘åˆ—è¡¨æ›´æ–°
            async checkForAlbumsUpdate() {
                setTimeout(async () => {
                    try {
                        console.log('åå°æ£€æŸ¥ä¸“è¾‘åˆ—è¡¨æ›´æ–°...');
                        
                        // è·å–æœ€æ–°çš„ä¸“è¾‘åˆ—è¡¨
                        const allReleases = await this.fetchAllReleases();
                        
                        // æ¯”è¾ƒæ–°æ—§åˆ—è¡¨æ˜¯å¦æœ‰å˜åŒ–
                        const oldIds = new Set(this.albumsCache.map(release => release.id));
                        const newIds = new Set(allReleases.map(release => release.id));
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰æ–°å¢æˆ–åˆ é™¤çš„ä¸“è¾‘
                        let hasChanges = false;
                        
                        // æ£€æŸ¥æ–°å¢
                        for (const id of newIds) {
                            if (!oldIds.has(id)) {
                                hasChanges = true;
                                break;
                            }
                        }
                        
                        // æ£€æŸ¥åˆ é™¤
                        if (!hasChanges) {
                            for (const id of oldIds) {
                                if (!newIds.has(id)) {
                                    hasChanges = true;
                                    break;
                                }
                            }
                        }
                        
                        if (hasChanges) {
                            console.log('ä¸“è¾‘åˆ—è¡¨æœ‰æ›´æ–°ï¼Œä¿å­˜æ–°åˆ—è¡¨å¹¶åˆ·æ–°é¡µé¢');
                            // ä¿å­˜æ–°çš„ä¸“è¾‘åˆ—è¡¨
                            this.saveAlbumsCache(allReleases);
                            // å»¶è¿Ÿä¸€ç§’ååˆ·æ–°é¡µé¢
                            setTimeout(() => {
                                window.location.reload();
                            }, 1000);
                        } else {
                            console.log('ä¸“è¾‘åˆ—è¡¨æ²¡æœ‰å˜åŒ–');
                        }
                        
                    } catch (error) {
                        console.warn('åå°æ£€æŸ¥ä¸“è¾‘åˆ—è¡¨æ›´æ–°å¤±è´¥:', error);
                        // å¤±è´¥ä¹Ÿæ²¡å…³ç³»ï¼Œä¸å½±å“å½“å‰ä½“éªŒ
                    }
                }, 5000); // å»¶è¿Ÿ5ç§’ååœ¨åå°æ£€æŸ¥ï¼Œé¿å…å½±å“åˆå§‹åŠ è½½ä½“éªŒ
            }
            
            // è·å–æ‰€æœ‰ä¸“è¾‘åˆ—è¡¨
            async fetchAllReleases() {
                const allReleases = [];
                const releaseIds = new Set(); // ç”¨äºå»é‡
                
                for (let i = 0; i < this.musicBrainzCollectionIds.length; i++) {
                    const collectionId = this.musicBrainzCollectionIds[i];
                    
                    try {
                        const releases = await this.fetchCollectionReleases(collectionId);
                        console.log(`ä»æ”¶è—æ  ${collectionId} è·å–åˆ° ${releases.length} ä¸ªä¸“è¾‘`);
                        
                        // å»é‡æ·»åŠ ä¸“è¾‘
                        for (const release of releases) {
                            if (!releaseIds.has(release.id)) {
                                releaseIds.add(release.id);
                                allReleases.push(release);
                            }
                        }
                    } catch (error) {
                        console.warn(`è·å–æ”¶è—æ  ${collectionId} å¤±è´¥:`, error);
                        // å¦‚æœè·å–å¤±è´¥ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªæ”¶è—æ 
                    }
                }
                
                console.log(`åˆå¹¶åå…±è·å–åˆ° ${allReleases.length} ä¸ªä¸é‡å¤ä¸“è¾‘`);
                return allReleases;
            }
            
            // ä» MusicBrainz æ”¶è—æ åŠ è½½ä¸“è¾‘
            async loadAlbumsFromMusicBrainz() {
                try {
                    this.updateLoadingMessage(this.formatText('loadingFromCollection', {
                        count: this.musicBrainzCollectionIds.length
                    }));

                    // ä»æ‰€æœ‰æ”¶è—æ è·å–ä¸“è¾‘åˆ—è¡¨
                    const allReleases = await this.fetchAllReleases();
                    
                    // ä¿å­˜ä¸“è¾‘åˆ—è¡¨åˆ°ç¼“å­˜
                    this.saveAlbumsCache(allReleases);
                    
                    console.log(`åˆå¹¶åå…±è·å–åˆ° ${allReleases.length} ä¸ªä¸é‡å¤ä¸“è¾‘`);
                    this.updateLoadingMessage(this.texts.loadingCovers);

                    // è·å–æ¯ä¸ªä¸“è¾‘çš„å°é¢ - ä½¿ç”¨å¹¶å‘è¯·æ±‚
                    let loadedCount = 0;
                    const totalCount = allReleases.length;
                    
                    // å¹¶å‘åŠ è½½å°é¢ï¼Œæ¯æ‰¹æ¬¡15ä¸ª
                    const batchSize = 15;
                    for (let i = 0; i < totalCount; i += batchSize) {
                        const batch = allReleases.slice(i, i + batchSize);
                        const promises = batch.map(async (release) => {
                            // å¯¹æ¯ä¸ªå°é¢æ·»åŠ é‡è¯•æœºåˆ¶
                            let retryCount = 0;
                            const maxRetries = 2;
                            
                            while (retryCount <= maxRetries) {
                                try {
                                    const coverUrl = await this.getCoverArt(release.id);
                                    // ç›´æ¥æ·»åŠ åˆ°åˆ—è¡¨ï¼Œä¸æ£€æŸ¥æ˜¯å¦ä¸ºç©º
                                    this.albums.push(coverUrl);
                                    this.albumUrls[coverUrl] = `https://musicbrainz.org/release/${release.id}`;
                                    loadedCount++;
                                    return 1;
                                } catch (error) {
                                    retryCount++;
                                    if (retryCount <= maxRetries) {
                                        console.warn(`è·å–å°é¢å¤±è´¥ï¼Œé‡è¯• (${retryCount}/${maxRetries}): ${release.title || release.id}`);
                                        // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                                        await new Promise(resolve => setTimeout(resolve, 300 * retryCount));
                                    } else {
                                        console.warn(`æ— æ³•åŠ è½½ä¸“è¾‘å°é¢: ${release.title || release.id}`, error);
                                        return 0;
                                    }
                                }
                            }
                            return 0;
                        });
                        
                        // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                        await Promise.all(promises);
                        
                        // æ›´æ–°åŠ è½½è¿›åº¦
                        this.updateLoadingMessage(
                            this.texts.loadingCovers,
                            this.formatText('loadingProgress', {
                                current: loadedCount,
                                total: totalCount
                            })
                        );
                    }

                    console.log(`âœ… æˆåŠŸåŠ è½½ ${this.albums.length} å¼ ä¸“è¾‘å°é¢`);
                    this.saveCoverCache(); // ä¿å­˜ç¼“å­˜

                } catch (error) {
                    console.error('âŒ ä» MusicBrainz åŠ è½½ä¸“è¾‘å¤±è´¥:', error.message);
                    // ä¸è‡ªåŠ¨å›é€€åˆ°æœ¬åœ°æ¨¡å¼ï¼Œè€Œæ˜¯æŠ›å‡ºé”™è¯¯
                    throw new Error(this.formatText('errorCollection', {
                        ids: this.musicBrainzCollectionIds.join(', ')
                    }) + `: ${error.message}`);
                }
            }

            // è·å– MusicBrainz æ”¶è—æ ä¸­çš„ä¸“è¾‘åˆ—è¡¨
            async fetchCollectionReleases(collectionId) {
                // ä½¿ç”¨ CORS ä»£ç†æ¥è®¿é—® MusicBrainz API
                const proxyUrls = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://cors-anywhere.herokuapp.com/'
                ];
                
                const targetUrl = `https://musicbrainz.org/ws/2/release?collection=${collectionId}&limit=100&fmt=json`;
                
                // å°è¯•ä¸åŒçš„ä»£ç†
                for (let i = 0; i < proxyUrls.length; i++) {
                    const proxyUrl = proxyUrls[i];
                    const url = proxyUrl + encodeURIComponent(targetUrl);
                    
                    try {
                        console.log(`å°è¯•ä½¿ç”¨ä»£ç† ${i+1}/${proxyUrls.length} è·å–æ”¶è—æ  ${collectionId}`);
                        
                        // æ·»åŠ é‡è¯•æœºåˆ¶
                        let retryCount = 0;
                        const maxRetries = 2;
                        
                        while (retryCount <= maxRetries) {
                            try {
                                const response = await fetch(url);
                                
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                }
                                
                                // è§£æå“åº”
                                const data = await response.json();
                                console.log(`âœ… æˆåŠŸè·å–æ”¶è—æ  ${collectionId} (ä½¿ç”¨ä»£ç† ${i+1})`);
                                return data.releases || [];
                            } catch (fetchError) {
                                retryCount++;
                                if (retryCount <= maxRetries) {
                                    console.warn(`è·å–æ”¶è—æ å¤±è´¥ï¼Œé‡è¯• (${retryCount}/${maxRetries})`, fetchError);
                                    // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                                    await new Promise(resolve => setTimeout(resolve, 500 * retryCount));
                                } else {
                                    // è¶…è¿‡é‡è¯•æ¬¡æ•°ï¼Œå°è¯•ä¸‹ä¸€ä¸ªä»£ç†
                                    console.error(`ä½¿ç”¨ä»£ç† ${i+1} è·å–æ”¶è—æ  ${collectionId} å¤±è´¥:`, fetchError);
                                    break;
                                }
                            }
                        }
                    } catch (error) {
                        console.error(`ä½¿ç”¨ä»£ç† ${i+1} è·å–æ”¶è—æ  ${collectionId} å¤±è´¥:`, error);
                        // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä»£ç†
                    }
                }
                
                // æ‰€æœ‰ä»£ç†éƒ½å¤±è´¥äº†
                throw new Error(`æ— æ³•è·å–æ”¶è—æ  ${collectionId}ï¼Œæ‰€æœ‰ä»£ç†éƒ½å¤±è´¥`);
            }

            // è·å–ä¸“è¾‘å°é¢
            async getCoverArt(releaseId) {
                // å…ˆæ£€æŸ¥ç¼“å­˜
                const cacheKey = `cover_${releaseId}`;
                if (this.coverCache.has(cacheKey)) {
                    const cached = this.coverCache.get(cacheKey);
                    console.log(`ä½¿ç”¨ç¼“å­˜çš„å°é¢: ${releaseId}`);
                    return cached.url;
                }

                // ä» Cover Art Archive è·å–å°é¢ URL (ä¸è¿›è¡Œæ£€æµ‹)
                const url = `https://coverartarchive.org/release/${releaseId}/front-500`;
                
                // ç›´æ¥å°† URL ä¿å­˜åˆ°ç¼“å­˜ä¸­ï¼Œä¸æ£€æµ‹æ˜¯å¦å¯ç”¨
                console.log(`æ·»åŠ å°é¢åˆ°ç¼“å­˜: ${releaseId}`);
                this.coverCache.set(cacheKey, {
                    url: url,
                    timestamp: Date.now()
                });
                
                return url;
            }

            async loadAlbumsFromBackup() {
                console.log('ä½¿ç”¨æœ¬åœ°ä¸“è¾‘åˆ—è¡¨...');
                this.updateLoadingMessage(this.texts.loadingBackup);

                try {
                    // æ¸…ç©ºç°æœ‰ä¸“è¾‘åˆ—è¡¨ï¼Œç¡®ä¿ä½¿ç”¨æœ¬åœ°å›¾ç‰‡
                    this.albums = [];
                    this.albumUrls = {};
                    
                    // è·å–å½“å‰é¡µé¢çš„åŸºç¡€URL
                    const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');
                    const coverDirUrl = `${baseUrl}cover/`;
                    
                    // è‡ªåŠ¨æ‰«æ cover ç›®å½•
                    console.log('è‡ªåŠ¨æ‰«æ cover ç›®å½•...');
                    this.updateLoadingMessage(this.texts.scanningDirectory);
                    
                    try {
                        // æ‰«æç›®å½• - æ–°çš„scanCoverDirectoryå‡½æ•°ä¼šç›´æ¥æ·»åŠ æ‰€æœ‰å·²çŸ¥å›¾ç‰‡
                        await this.scanCoverDirectory(coverDirUrl);
                    } catch (scanError) {
                        console.warn('æ‰«æç›®å½•å¤±è´¥:', scanError);
                        
                        // å¦‚æœæ‰«æå®Œå…¨å¤±è´¥ï¼Œæ·»åŠ ä¸€ä¸ªé»˜è®¤å›¾ç‰‡
                        if (this.albums.length === 0) {
                            const defaultImage = `${coverDirUrl}1.jpg`;
                            this.albums.push(defaultImage);
                            this.albumUrls[defaultImage] = this.generateAlbumUrl('1.jpg');
                            console.warn('æ‰«æå¤±è´¥ï¼Œæ·»åŠ é»˜è®¤å›¾ç‰‡');
                        }
                    }

                    console.log(`âœ… æœ¬åœ°ä¸“è¾‘åˆ—è¡¨åŠ è½½å®Œæˆï¼Œå…± ${this.albums.length} å¼ ä¸“è¾‘å°é¢`);

                } catch (error) {
                    console.error('åŠ è½½æœ¬åœ°ä¸“è¾‘åˆ—è¡¨å¤±è´¥:', error);
                    // å³ä½¿å¤±è´¥ä¹Ÿä¸æŠ›å‡ºé”™è¯¯ï¼Œè€Œæ˜¯æ·»åŠ ä¸€ä¸ªé»˜è®¤å›¾ç‰‡
                    const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');
                    const defaultImage = `${baseUrl}cover/1.jpg`;
                    this.albums = [defaultImage];
                    this.albumUrls[defaultImage] = this.generateAlbumUrl('1.jpg');
                    console.warn('åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å›¾ç‰‡');
                }
            }
            
            // æ‰«æ cover ç›®å½•ä¸‹çš„æ‰€æœ‰å›¾ç‰‡æ–‡ä»¶
            async scanCoverDirectory(coverDirUrl) {
                try {
                    console.log('å¼€å§‹æ‰«ææœ¬åœ°ç›®å½•:', coverDirUrl);
                    
                    // é¦–å…ˆå°è¯•ç›´æ¥åˆ—å‡ºæ‰€æœ‰å·²çŸ¥çš„å›¾ç‰‡æ–‡ä»¶
                    const knownFiles = [
                        '1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg'
                    ];
                    
                    let foundImages = 0;
                    
                    // å…ˆæ·»åŠ æ‰€æœ‰å·²çŸ¥çš„å›¾ç‰‡æ–‡ä»¶ 
                    for (const filename of knownFiles) {
                        const imageUrl = `${coverDirUrl}${filename}`;
                        this.albums.push(imageUrl);
                        this.albumUrls[imageUrl] = this.generateAlbumUrl(filename);
                        foundImages++;
                    }
                    
                    console.log(`å·²æ·»åŠ  ${foundImages} ä¸ªå·²çŸ¥å›¾ç‰‡æ–‡ä»¶`);
                    
                    // ç„¶åå°è¯•ä½¿ç”¨iframeæ‰«æç›®å½•
                    try {
                        // åˆ›å»ºä¸€ä¸ªéšè—çš„ iframe æ¥è·å–ç›®å½•åˆ—è¡¨
                        const iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        document.body.appendChild(iframe);
                        
                        await new Promise((resolve, reject) => {
                            iframe.onload = () => {
                                try {
                                    // å°è¯•ä» iframe ä¸­è·å–ç›®å½•å†…å®¹
                                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                                    
                                    // æŸ¥æ‰¾æ‰€æœ‰é“¾æ¥ï¼Œè¿™äº›é“¾æ¥å¯èƒ½æ˜¯æ–‡ä»¶
                                    const links = iframeDoc.querySelectorAll('a');
                                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                                    let iframeFounds = 0;
                                    
                                    // éå†æ‰€æœ‰é“¾æ¥ï¼Œå¯»æ‰¾å›¾ç‰‡æ–‡ä»¶
                                    for (const link of links) {
                                        const href = link.getAttribute('href');
                                        
                                        // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡æ–‡ä»¶ä¸”ä¸åœ¨å·²çŸ¥æ–‡ä»¶åˆ—è¡¨ä¸­
                                        if (href && imageExtensions.some(ext => href.toLowerCase().endsWith(ext)) && 
                                            !knownFiles.includes(href)) {
                                            const filename = href;
                                            const imageUrl = `${coverDirUrl}${filename}`;
                                            
                                            // æ·»åŠ åˆ°ä¸“è¾‘åˆ—è¡¨
                                            this.albums.push(imageUrl);
                                            this.albumUrls[imageUrl] = this.generateAlbumUrl(filename);
                                            iframeFounds++;
                                            foundImages++;
                                        }
                                    }
                                    
                                    console.log(`iframeæ‰«æé¢å¤–æ‰¾åˆ° ${iframeFounds} ä¸ªå›¾ç‰‡æ–‡ä»¶`);
                                    
                                    // æ¸…ç† iframe
                                    document.body.removeChild(iframe);
                                    resolve();
                                } catch (error) {
                                    if (document.body.contains(iframe)) {
                                        document.body.removeChild(iframe);
                                    }
                                    console.warn('iframeæ‰«æå¤±è´¥:', error);
                                    resolve(); // å³ä½¿å¤±è´¥ä¹Ÿç»§ç»­ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»æœ‰äº†å·²çŸ¥æ–‡ä»¶
                                }
                            };
                            
                            iframe.onerror = () => {
                                if (document.body.contains(iframe)) {
                                    document.body.removeChild(iframe);
                                }
                                console.warn('iframeåŠ è½½å¤±è´¥');
                                resolve(); // å³ä½¿å¤±è´¥ä¹Ÿç»§ç»­ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»æœ‰äº†å·²çŸ¥æ–‡ä»¶
                            };
                            
                            // è®¾ç½® iframe çš„ src
                            iframe.src = coverDirUrl;
                            
                            // å¦‚æœ 3 ç§’åä»æœªåŠ è½½å®Œæˆï¼Œåˆ™è¶…æ—¶ä½†ä¸æŠ¥é”™
                            setTimeout(() => {
                                if (document.body.contains(iframe)) {
                                    document.body.removeChild(iframe);
                                    console.warn('iframeåŠ è½½è¶…æ—¶');
                                    resolve(); // å³ä½¿è¶…æ—¶ä¹Ÿç»§ç»­ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»æœ‰äº†å·²çŸ¥æ–‡ä»¶
                                }
                            }, 3000);
                        });
                    } catch (iframeError) {
                        console.warn('iframeæ‰«æå‡ºé”™ï¼Œä½†ç»§ç»­ä½¿ç”¨å·²çŸ¥æ–‡ä»¶:', iframeError);
                    }
                    
                    console.log(`æœ¬åœ°ç›®å½•æ‰«æå®Œæˆï¼Œæ€»å…±æ‰¾åˆ° ${foundImages} ä¸ªå›¾ç‰‡æ–‡ä»¶`);
                    
                    if (foundImages > 0) {
                        return;
                    } else {
                        throw new Error('æœªæ‰¾åˆ°ä»»ä½•å›¾ç‰‡æ–‡ä»¶');
                    }
                } catch (error) {
                    console.error('æ‰«æç›®å½•å¤±è´¥:', error);
                    throw error;
                }
            }

            // æ›´æ–°åŠ è½½æ¶ˆæ¯
            updateLoadingMessage(message, progress = '') {
                if (this.loadingText) {
                    this.loadingText.textContent = message;
                }
                if (this.loadingProgress) {
                    this.loadingProgress.textContent = progress;
                }
            }

            generateAlbumUrl(filename) {
                // ç”Ÿæˆæœç´¢URLçš„ç®€å•é€»è¾‘
                const albumName = filename.replace(/\.(jpg|jpeg|png|webp|gif|bmp)$/i, '');
                const cleanName = encodeURIComponent(albumName.replace(/[_\-\d\s()]/g, ' ').trim());

                // ä½¿ç”¨Googleæœç´¢å¹¶æ·»åŠ åœ¨çº¿æ’­æ”¾å…³é”®è¯
                return `https://www.google.com/search?q=${cleanName}+stream+online+listen`;
            }

            // åˆå§‹åŒ–ä¸»åœºæ™¯çš„Three.js
            initThreeJS() {
                // å¯ç”¨Three.jsç¼“å­˜ï¼Œå‡å°‘é‡å¤è§£ç ä¸ä¸Šä¼ 
                THREE.Cache.enabled = true;

                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);

                // è®¡ç®—åˆé€‚çš„ç›¸æœºå‚æ•°ä»¥å¡«æ»¡å±å¹•
                const aspect = window.innerWidth / window.innerHeight;

                // ä½¿ç”¨é€è§†ç›¸æœºä»¥è·å¾—çœŸå®ç«‹ä½“æ—‹è½¬
                this.frustumSize = 20;
                this.fov = 45;
                this.camera = new THREE.PerspectiveCamera(this.fov, aspect, 0.1, 1000);
                // è®¡ç®—ä½¿ z=0 å¹³é¢å¯è§†é«˜åº¦ç­‰äº frustumSize çš„ç›¸æœºè·ç¦»
                const distance = this.frustumSize / (2 * Math.tan(THREE.MathUtils.degToRad(this.fov / 2)));
                this.camera.position.set(0, 0, distance);
                this.camera.lookAt(0, 0, 0);

                // åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆé«˜æ€§èƒ½åå¥½ï¼Œé™ä½åƒç´ å¯†åº¦ã€å…³é—­æŠ—é”¯é½¿ï¼‰
                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(1.25, window.devicePixelRatio));
                this.container.appendChild(this.renderer.domElement);

                // ç”±äºæ”¹ç”¨Basicæè´¨ï¼Œç§»é™¤å…‰ç…§å¯å‡å°‘ç‰‡æ®µç€è‰²å¼€é”€ï¼ˆå¦‚éœ€å¾®å¼±ç«‹ä½“æ„Ÿå¯å†å¼€å¯ï¼‰
                // const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                // this.scene.add(ambientLight);
                // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2);
                // directionalLight.position.set(0, 0, 5);
                // this.scene.add(directionalLight);

                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => {
                    const newAspect = window.innerWidth / window.innerHeight;
                    this.camera.aspect = newAspect;
                    this.camera.updateProjectionMatrix();
                    // ç»´æŒ z=0 å¹³é¢çš„å¯è§†é«˜åº¦ç­‰äº frustumSize
                    const distance = this.frustumSize / (2 * Math.tan(THREE.MathUtils.degToRad(this.fov / 2)));
                    this.camera.position.set(0, 0, distance);
                    this.renderer.setSize(window.innerWidth, window.innerHeight);

                    // é‡æ–°è®¡ç®—ç½‘æ ¼å¸ƒå±€
                    this.recalculateGrid();
                });
                
                // æ›´æ–°åœºæ™¯èƒŒæ™¯é¢œè‰² - ä½¿ç”¨ä¿å­˜çš„é¢œè‰²æˆ–é»˜è®¤é¢œè‰²
                this.updateBackgroundColor(this.savedBackgroundColor || '#000000');
            }
            
            // åˆå§‹åŒ–3Då±•ç¤ºå°åœºæ™¯
            initShowcaseScene() {
                // åˆ›å»ºå±•ç¤ºå°åœºæ™¯
                this.showcaseScene = new THREE.Scene();
                // è®¾ç½®ä¸ºé€æ˜èƒŒæ™¯ï¼Œè®©å°é¢æ‚¬æµ®åœ¨åº•å±‚ä¸Š
                this.showcaseScene.background = null;
                
                // è®¾ç½®å±•ç¤ºå°ç›¸æœº
                const canvas = document.getElementById('album-showcase-canvas');
                const aspect = canvas.clientWidth / canvas.clientHeight;
                this.showcaseCamera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
                this.showcaseCamera.position.set(0, 0, 6); // å°†ç›¸æœºæ”¾åœ¨Zè½´ä¸Šï¼Œä¸å°é¢åœ¨åŒä¸€æ°´å¹³çº¿
                this.showcaseCamera.lookAt(0, 0, 0); // ç›´æ¥çœ‹å‘åœºæ™¯ä¸­å¿ƒ
                
                // åˆ›å»ºå±•ç¤ºå°æ¸²æŸ“å™¨
                this.showcaseRenderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true, 
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                this.showcaseRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
                
                // ä¸ºå±•ç¤ºå°å¯ç”¨é˜´å½±ç³»ç»Ÿ
                this.showcaseRenderer.shadowMap.enabled = true;
                this.showcaseRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // ä½¿ç”¨æœ€åŸå§‹çš„é¢œè‰²æ˜¾ç¤ºæ–¹å¼ï¼Œä¸è¿›è¡Œä»»ä½•é¢œè‰²ç©ºé—´è½¬æ¢
                // this.showcaseRenderer.outputEncoding = THREE.sRGBEncoding;
                // å¯ç”¨é€æ˜åº¦æ”¯æŒ
                this.showcaseRenderer.setClearColor(0x000000, 0);
                
                console.log('3Då±•ç¤ºå°åœºæ™¯åˆå§‹åŒ–å®Œæˆï¼ˆé€æ˜èƒŒæ™¯ï¼‰');
            }
            
            // åˆ›å»ºå±•ç¤ºå°å‡ ä½•ä½“å’Œæè´¨ï¼ˆå·²åˆ é™¤åº•åº§ï¼‰
            createShowcaseStand() {
                // ä¸å†åˆ›å»ºåº•åº§ï¼Œä¿ç•™å‡½æ•°ä»¥é¿å…è°ƒç”¨é”™è¯¯
                console.log('å±•ç¤ºå°åˆå§‹åŒ–å®Œæˆï¼ˆæ— åº•åº§ï¼‰');
            }
            
            // åˆ›å»ºä¸“è¾‘å°é¢3Då±•ç¤ºç½‘æ ¼
            createShowcaseCover(albumPath) {
                // æ¸…ç†æ—§çš„å°é¢ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.showcaseCover) {
                    this.showcaseScene.remove(this.showcaseCover);
                    if (this.showcaseCover.material.map) {
                        this.showcaseCover.material.map.dispose();
                    }
                    this.showcaseCover.material.dispose();
                    this.showcaseCover.geometry.dispose();
                }
                
                // åˆ›å»ºå°é¢å‡ ä½•ä½“ï¼ˆæ­£æ–¹å½¢å¹³é¢ï¼Œæ”¾å¤§å°ºå¯¸ï¼‰
                const coverGeometry = new THREE.PlaneGeometry(3.5, 3.5);
                
                // åˆ›å»ºæè´¨ï¼ˆåˆå§‹ä¸ºé€æ˜ï¼Œç­‰å¾…çº¹ç†åŠ è½½ï¼‰- ä½¿ç”¨æ ‡å‡†æè´¨å®ç°å°åˆ·å“åå°„
                const coverMaterial = new THREE.MeshStandardMaterial({ 
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide,
                    metalness: 0.0,        // éé‡‘å±æè´¨ï¼Œæ¨¡æ‹Ÿçº¸è´¨æµ·æŠ¥
                    roughness: 0.85,       // é€‚åº¦ç²—ç³™åº¦ï¼Œæä¾›æŸ”å’Œäº®é¢åå°„
                    emissive: 0x000000,    // æ— è‡ªå‘å…‰
                    envMapIntensity: 0.3   // é™ä½ç¯å¢ƒæ˜ å°„å½±å“
                });
                
                // åˆ›å»ºå°é¢ç½‘æ ¼ï¼ˆè°ƒæ•´ä½ç½®ä½¿å…¶å±…ä¸­æ˜¾ç¤ºï¼‰
                this.showcaseCover = new THREE.Mesh(coverGeometry, coverMaterial);
                this.showcaseCover.position.set(0, 0, 0); // æ”¾åœ¨åœºæ™¯æ­£ä¸­å¿ƒ
                this.showcaseCover.rotation.x = 0; // å»é™¤å€¾æ–œï¼Œä¿æŒå‚ç›´
                
                // ä¸ºå±•ç¤ºå°å°é¢å¯ç”¨é˜´å½±
                this.showcaseCover.castShadow = true;
                this.showcaseCover.receiveShadow = true;
                
                // åŠ è½½çº¹ç†
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    albumPath,
                    (texture) => {
                        // çº¹ç†åŠ è½½æˆåŠŸ
                        this.adjustTextureForShowcase(texture);
                        this.showcaseCover.material.map = texture;
                        this.showcaseCover.material.needsUpdate = true;
                        
                        // æ¸æ˜¾åŠ¨ç”»
                        this.fadeInShowcaseCover();
                        
                        console.log('å±•ç¤ºå°å°é¢çº¹ç†åŠ è½½æˆåŠŸ');
                    },
                    (progress) => {
                        // åŠ è½½è¿›åº¦
                        console.log('çº¹ç†åŠ è½½è¿›åº¦:', Math.round((progress.loaded / progress.total) * 100) + '%');
                    },
                    (error) => {
                        // åŠ è½½å¤±è´¥
                        console.error('å±•ç¤ºå°å°é¢çº¹ç†åŠ è½½å¤±è´¥:', error);
                        // ä½¿ç”¨é»˜è®¤é¢œè‰²
                        this.showcaseCover.material.color.setHex(0x333333);
                        this.fadeInShowcaseCover();
                    }
                );
                
                // æ·»åŠ åˆ°åœºæ™¯
                this.showcaseScene.add(this.showcaseCover);
                
                console.log('å±•ç¤ºå°å°é¢åˆ›å»ºå®Œæˆ');
            }
            
            // è°ƒæ•´å±•ç¤ºå°çº¹ç†ï¼ˆä¿æŒæ–¹å½¢æ¯”ä¾‹ï¼‰
            adjustTextureForShowcase(texture) {
                const image = texture.image;
                const imageAspect = image.width / image.height;
                
                if (imageAspect !== 1) {
                    if (imageAspect > 1) {
                        // å®½å›¾ï¼šè£åˆ‡å·¦å³ä¸¤è¾¹
                        const cropWidth = image.height;
                        const offsetX = (image.width - cropWidth) / 2 / image.width;
                        texture.offset.x = offsetX;
                        texture.repeat.x = cropWidth / image.width;
                        texture.repeat.y = 1;
                        texture.offset.y = 0;
                    } else {
                        // é«˜å›¾ï¼šè£åˆ‡ä¸Šä¸‹ä¸¤è¾¹
                        const cropHeight = image.width;
                        const offsetY = (image.height - cropHeight) / 2 / image.height;
                        texture.offset.y = offsetY;
                        texture.repeat.y = cropHeight / image.height;
                        texture.repeat.x = 1;
                        texture.offset.x = 0;
                    }
                }
                
                // è®¾ç½®çº¹ç†è¿‡æ»¤å’Œç¯ç»•æ¨¡å¼
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrap;
                texture.wrapT = THREE.ClampToEdgeWrap;
            }
            
            // å±•ç¤ºå°å°é¢æ¸æ˜¾åŠ¨ç”»
            fadeInShowcaseCover() {
                const duration = 800;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                    const easeProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    this.showcaseCover.material.opacity = easeProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.showcaseCover.material.opacity = 1;
                    }
                };
                
                animate();
            }
            
            // è®¾ç½®å±•ç¤ºå°é¼ æ ‡äº¤äº’ï¼ˆå…¨å±è¿½è¸ªï¼‰
            setupShowcaseMouseInteraction() {
                const canvas = document.getElementById('album-showcase-canvas');
                if (!canvas) return;
                
                // å…¨å±é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆç»‘å®šåˆ°documentä»¥æ”¯æŒå…¨å±è¿½è¸ªï¼‰
                this.showcaseMouseMoveHandler = (event) => {
                    if (!this.showcaseActive) return;
                    
                    // åŸºäºæ•´ä¸ªçª—å£è®¡ç®—é¼ æ ‡ä½ç½®
                    const x = event.clientX / window.innerWidth;
                    const y = event.clientY / window.innerHeight;
                    
                    // å°†é¼ æ ‡ä½ç½®è½¬æ¢ä¸º -1 åˆ° 1 çš„èŒƒå›´ï¼Œä»¥å±å¹•ä¸­å¿ƒä¸ºåŸºå‡†ç‚¹
                    this.mousePosition.x = (x - 0.5) * 2 * 1.2; // é€‚ä¸­çš„æ•æ„Ÿåº¦
                    this.mousePosition.y = (y - 0.5) * 2 * 1.2; // ä¿æŒåŸå§‹Yè½´æ˜ å°„ç”¨äºæ—‹è½¬
                    
                    // é™åˆ¶èŒƒå›´é¿å…è¿‡åº¦æ—‹è½¬
                    this.mousePosition.x = Math.max(-1.2, Math.min(1.2, this.mousePosition.x));
                    this.mousePosition.y = Math.max(-1.2, Math.min(1.2, this.mousePosition.y));
                    
                    // ç¦ç”¨å¼¹ç°§é˜»å°¼æ•ˆæœï¼Œé¿å…æµ®åŠ¨
                    // ç§»é™¤æ‰€æœ‰ç‰©ç†ç³»ç»Ÿçš„é€Ÿåº¦æ–½åŠ ï¼Œç¡®ä¿å°é¢åªè·Ÿéšé¼ æ ‡ä½ç½®
                    /*
                    if (this.showcaseCover && this.showcaseCover.userData.physics) {
                        const physics = this.showcaseCover.userData.physics;
                        // æ–½åŠ ä¸é¼ æ ‡ç§»åŠ¨æ–¹å‘ç›¸å…³çš„åŠ›ï¼Œæ¨¡æ‹Ÿå¼¹ç°§åé¦ˆ
                        physics.velocity.x = -this.mousePosition.x * 0.12;
                        physics.velocity.y = this.mousePosition.y * 0.12; // å¢å¼ºYè½´æ•ˆæœ
                        physics.velocity.z = Math.abs(this.mousePosition.x) * 0.05; // æ·»åŠ Zè½´æ•ˆæœ
                        
                        // å¢å¼ºè§’é€Ÿåº¦æ•ˆæœï¼Œæ”¯æŒä¸Šä¸‹åè½¬
                        physics.angularVelocity.x = this.mousePosition.y * 0.08; // å¢å¼ºç»•Xè½´æ—‹è½¬
                        physics.angularVelocity.y = -this.mousePosition.x * 0.08; // å¢å¼ºç»•Yè½´æ—‹è½¬
                        physics.angularVelocity.z = (this.mousePosition.x - this.mousePosition.y) * 0.05; // æ·»åŠ ç»•Zè½´æ—‹è½¬
                    }
                    */
                };
                
                // ç»‘å®šå…¨å±é¼ æ ‡ç§»åŠ¨äº‹ä»¶
                document.addEventListener('mousemove', this.showcaseMouseMoveHandler);
                
                // é¼ æ ‡é™æ­¢æ£€æµ‹ï¼ˆå½“é¼ æ ‡é•¿æ—¶é—´ä¸åŠ¨æ—¶å¤ä½ï¼‰
                this.mouseIdleTimer = null;
                this.showcaseMouseIdleHandler = () => {
                    if (this.mouseIdleTimer) {
                        clearTimeout(this.mouseIdleTimer);
                    }
                    this.mouseIdleTimer = setTimeout(() => {
                        this.resetShowcasePosition();
                    }, 60000); // 1åˆ†é’Ÿåå¤ä½
                };
                
                document.addEventListener('mousemove', this.showcaseMouseIdleHandler);
                
                console.log('å±•ç¤ºå°å…¨å±é¼ æ ‡äº¤äº’è®¾ç½®å®Œæˆ');
            }
            
            // æ›´æ–°å±•ç¤ºå°å°é¢ä½ç½®å’Œæ—‹è½¬ï¼ˆæ ¹æ®é¼ æ ‡ä½ç½®ï¼‰
            updateShowcaseCoverTransform() {
                if (!this.showcaseCover || !this.showcaseActive) return;
                
                // è·å–ç‰©ç†å±æ€§
                const physics = this.showcaseCover.userData.physics;
                const shakeParams = this.showcaseCover.userData.shakeParams;
                
                // ç¦ç”¨å¼¹ç°§é˜»å°¼ç‰©ç†æ•ˆæœæ›´æ–°ï¼Œé¿å…æµ®åŠ¨
                // å®Œå…¨ç§»é™¤ç‰©ç†ç³»ç»Ÿæ›´æ–°ï¼Œç¡®ä¿å°é¢åªè·Ÿéšé¼ æ ‡
                /*
                if (physics && (Math.abs(physics.velocity.x) > 0.001 || Math.abs(physics.velocity.y) > 0.001 || 
                    Math.abs(physics.angularVelocity.x) > 0.001 || Math.abs(physics.angularVelocity.y) > 0.001)) {
                    // å¼¹ç°§-é˜»å°¼ç³»ç»Ÿæ›´æ–°
                    if (shakeParams) {
                        // è®¡ç®—å¼¹ç°§åŠ› (F = -kx)
                        const springForce = physics.position.clone().multiplyScalar(-shakeParams.springConstant);
                        
                        // è®¡ç®—é˜»å°¼åŠ› (F = -cv)
                        const dampingForce = physics.velocity.clone().multiplyScalar(-shakeParams.damping);
                        
                        // æ€»åŠ› = å¼¹ç°§åŠ› + é˜»å°¼åŠ›
                        const totalForce = springForce.add(dampingForce);
                        
                        // åŠ é€Ÿåº¦ = åŠ› / è´¨é‡ (a = F/m)
                        physics.acceleration.copy(totalForce).divideScalar(shakeParams.mass);
                        
                        // æ›´æ–°é€Ÿåº¦ (v = v0 + a * dt)
                        physics.velocity.add(physics.acceleration.clone().multiplyScalar(0.016)); // å‡è®¾60fps
                        
                        // æ›´æ–°ä½ç½® (x = x0 + v * dt)
                        physics.position.add(physics.velocity.clone().multiplyScalar(0.016));
                        
                        // è§’è¿åŠ¨ç±»ä¼¼å¤„ç†
                        // è§’å¼¹ç°§åŠ›
                        const angularSpringForce = physics.rotation.clone().multiplyScalar(-shakeParams.springConstant);
                        // è§’é˜»å°¼åŠ›
                        const angularDampingForce = physics.angularVelocity.clone().multiplyScalar(-shakeParams.damping);
                        // æ€»è§’åŠ›
                        const totalAngularForce = angularSpringForce.add(angularDampingForce);
                        // è§’åŠ é€Ÿåº¦
                        physics.angularAcceleration.copy(totalAngularForce).divideScalar(shakeParams.mass);
                        // æ›´æ–°è§’é€Ÿåº¦
                        physics.angularVelocity.add(physics.angularAcceleration.clone().multiplyScalar(0.016));
                        // æ›´æ–°è§’åº¦
                        physics.rotation.add(physics.angularVelocity.clone().multiplyScalar(0.016));
                        
                        // å¦‚æœè¿åŠ¨å·²ç»åŸºæœ¬åœæ­¢ï¼Œé‡ç½®é€Ÿåº¦
                        const velocityMagnitude = physics.velocity.length();
                        const angularVelocityMagnitude = physics.angularVelocity.length();
                        if (velocityMagnitude < 0.001 && angularVelocityMagnitude < 0.001) {
                            physics.velocity.set(0, 0, 0);
                            physics.angularVelocity.set(0, 0, 0);
                        }
                    }
                }
                */
                
                // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆé’ˆå¯¹é€è§†æ•ˆåº”è°ƒæ•´ä¸Šä¸‹æ—‹è½¬å¹…åº¦ï¼‰
                const maxRotation = Math.PI * 0.15; // æ—‹è½¬å¹…åº¦åˆ°æœ€å¤§27åº¦
                const targetRotationY = this.mousePosition.x * maxRotation;
                const targetRotationX = this.mousePosition.y * maxRotation * 0.6; // é’ˆå¯¹é€è§†è§†è§‰æ•ˆåº”ï¼Œå‡å°ä¸Šä¸‹æ—‹è½¬å¹…åº¦
                
                // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆç»Ÿä¸€å·¦å³å’Œä¸Šä¸‹çš„ä½ç§»å¹…åº¦ï¼Œå¢å¼ºä½ç§»è¡¥å¿ï¼‰
                const maxOffset = 0.35; // ä½ç½®ä½ç§»å¹…åº¦
                const targetX = this.mousePosition.x * maxOffset;
                const targetY = -this.mousePosition.y * maxOffset; // åè½¬Yè½´ä½ç§»ï¼Œé¼ æ ‡å‘ä¸Šæ—¶å°é¢å‘ä¸Šç§»åŠ¨
                const targetZ = this.mousePosition.y * maxOffset * 0.3; // å‡å°‘Zè½´ä½ç§»ï¼Œé¿å…è¿‡åº¦å‰åç§»åŠ¨
                
                // æé«˜å“åº”é€Ÿåº¦
                const lerpFactor = 0.15; // æé«˜å“åº”é€Ÿåº¦
                
                // æ›´æ–°æ—‹è½¬ï¼ˆç»Ÿä¸€å·¦å³å’Œä¸Šä¸‹çš„å¤„ç†æ–¹å¼ï¼‰
                // å·¦å³æ—‹è½¬ï¼ˆYè½´ï¼‰- ä½¿ç”¨å¹³æ»‘æ’å€¼
                this.showcaseCover.rotation.y += (targetRotationY - this.showcaseCover.rotation.y) * lerpFactor;
                // ä¸Šä¸‹æ—‹è½¬ï¼ˆXè½´ï¼‰- åŒæ ·ä½¿ç”¨å¹³æ»‘æ’å€¼ï¼Œä¿æŒä¸€è‡´æ€§
                this.showcaseCover.rotation.x += (targetRotationX - this.showcaseCover.rotation.x) * lerpFactor;
                
                // æ·»åŠ å¼¹ç°§æ—‹è½¬æ•ˆæœï¼ˆä¸é¼ æ ‡äº¤äº’å åŠ ï¼‰- å‡å¼±å¼ºåº¦é¿å…è¿‡åº¦æ™ƒåŠ¨
                this.showcaseCover.rotation.x += physics.rotation.x * 0.00; // å‡å¼±Xè½´æ—‹è½¬æ•ˆæœ
                this.showcaseCover.rotation.y += physics.rotation.y * 0.00; // å‡å¼±Yè½´æ—‹è½¬æ•ˆæœ
                this.showcaseCover.rotation.z = physics.rotation.z * 0.00; // å‡å¼±Zè½´æ—‹è½¬æ•ˆæœ
                
                // æ›´æ–°ä½ç½®ï¼ˆç»“åˆé¼ æ ‡äº¤äº’å’Œå¼¹ç°§æ•ˆæœï¼Œæ”¯æŒä¸Šä¸‹åè½¬ï¼‰- å‡å¼±å¼ºåº¦é¿å…è¿‡åº¦æ™ƒåŠ¨
                this.showcaseCover.position.x = targetX + physics.position.x * 0.00; // å‡å¼±Xè½´ä½ç§»æ•ˆæœ
                this.showcaseCover.position.y = targetY + physics.position.y * 0.00; // å‡å¼±Yè½´ä½ç§»æ§åˆ¶
                this.showcaseCover.position.z = targetZ + physics.position.z * 0.00; // å‡å¼±Zè½´ä½ç§»æ•ˆæœ
            }
            
            // é‡ç½®å±•ç¤ºå°ä½ç½®
            resetShowcasePosition() {
                this.mousePosition = { x: 0, y: 0 };
                // å¼ºåˆ¶é‡ç½®æ‰€æœ‰æ—‹è½¬è½´ä¸º0ï¼Œç¡®ä¿å°é¢åœ¨é¼ æ ‡å±…ä¸­æ—¶å®Œå…¨æ°´å¹³
                if (this.showcaseCover) {
                    this.showcaseCover.rotation.x = 0;
                    this.showcaseCover.rotation.y = 0;
                    this.showcaseCover.rotation.z = 0;
                    this.showcaseCover.position.x = 0;
                    this.showcaseCover.position.y = 0;
                    this.showcaseCover.position.z = 0;
                    
                    // é‡ç½®ç‰©ç†çŠ¶æ€
                    if (this.showcaseCover.userData.physics) {
                        const physics = this.showcaseCover.userData.physics;
                        physics.position.set(0, 0, 0);
                        physics.velocity.set(0, 0, 0);
                        physics.acceleration.set(0, 0, 0);
                        physics.rotation.set(0, 0, 0);
                        physics.angularVelocity.set(0, 0, 0);
                        physics.angularAcceleration.set(0, 0, 0);
                        physics.isShaking = false;
                        physics.shakeStartTime = 0;
                        physics.shakeIntensity = 0;
                    }
                }
                console.log('é‡ç½®å±•ç¤ºå°ä½ç½®å’Œæ—‹è½¬');
            }
            
            // è®¾ç½®å±•ç¤ºå°å…‰ç…§ç³»ç»Ÿï¼ˆä¸“ä¸šå››å…‰æºç…§æ˜ï¼‰
            setupShowcaseLights() {
                // æ¸…ç†æ—§çš„ç¯å…‰
                this.showcaseLights.forEach(light => {
                    this.showcaseScene.remove(light);
                    if (light.target && light.target.parent) {
                        this.showcaseScene.remove(light.target);
                    }
                });
                this.showcaseLights = [];
                
                // 1. ç¯å¢ƒå…‰ - æä¾›åŸºç¡€ç…§æ˜
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
                this.showcaseLights.push(ambientLight);
                this.showcaseScene.add(ambientLight);
                
                // 2. ä¸»å…‰æº - æä¾›ä¸»è¦äº®é¢åå°„
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.9);
                mainLight.position.set(4, 6, 3);
                mainLight.target.position.set(0, 0, 0);
                
                // é…ç½®ä¸»å…‰æºé˜´å½±
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 1024;
                mainLight.shadow.mapSize.height = 1024;
                mainLight.shadow.bias = -0.0005;
                
                this.showcaseLights.push(mainLight);
                this.showcaseScene.add(mainLight);
                this.showcaseScene.add(mainLight.target);
                
                // 3. è¡¥å……å…‰ - å‡å°‘é˜´å½±å¯¹æ¯”åº¦
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
                fillLight.position.set(-3, 2, 2);
                fillLight.target.position.set(0, 0, 0);
                this.showcaseLights.push(fillLight);
                this.showcaseScene.add(fillLight);
                this.showcaseScene.add(fillLight.target);
                
                // 4. é¡¶éƒ¨è½¯å…‰ - æ¨¡æ‹Ÿå¤©èŠ±æ¿æ¼«åå°„
                const topLight = new THREE.DirectionalLight(0xffffff, 0.1);
                topLight.position.set(0, 10, 0);
                topLight.target.position.set(0, 0, 0);
                this.showcaseLights.push(topLight);
                this.showcaseScene.add(topLight);
                this.showcaseScene.add(topLight.target);
                
                console.log('å±•ç¤ºå°ä¸“ä¸šå…‰ç…§ç³»ç»Ÿè®¾ç½®å®Œæˆï¼ˆå°åˆ·å“åå°„æ¨¡å¼ï¼‰');
            }
            
            // å±•ç¤ºå°åŠ¨ç”»å¾ªç¯
            startShowcaseAnimation() {
                if (this.showcaseAnimationId) {
                    cancelAnimationFrame(this.showcaseAnimationId);
                }
                
                const animate = () => {
                    if (!this.showcaseActive) return;
                    
                    // æ›´æ–°é¼ æ ‡è·Ÿéšäº¤äº’
                    this.updateShowcaseCoverTransform();
                    
                    // ç¦ç”¨æ‚¬æµ®åŠ¨ç”»å’Œå¼¹ç°§æ•ˆæœï¼Œé¿å…æµ®åŠ¨
                    // ç§»é™¤æ‰€æœ‰è‡ªåŠ¨æµ®åŠ¨å’Œç‰©ç†åé¦ˆï¼Œè®©å°é¢å®Œå…¨è·Ÿéšé¼ æ ‡
                    /*
                    if (this.showcaseCover) {
                        const time = Date.now() * 0.001;
                        const floatingOffset = Math.sin(time * 1.5) * 0.03;
                        
                        // è·å–ç‰©ç†å±æ€§
                        const physics = this.showcaseCover.userData.physics;
                        
                        // åº”ç”¨æµ®åŠ¨æ•ˆæœå’Œå¼¹ç°§åé¦ˆï¼ˆæ”¯æŒä¸Šä¸‹åè½¬ï¼‰
                        if (physics) {
                            // åŸºç¡€Yè½´æµ®åŠ¨ - ä¸é¼ æ ‡æ§åˆ¶çš„Yè½´ä½ç½®ç»“åˆ
                            this.showcaseCover.position.y += (floatingOffset + physics.position.y * 0.4 - this.showcaseCover.position.y) * 0.1;
                            
                            // å¼¹ç°§åé¦ˆ
                            this.showcaseCover.position.x += physics.position.x * 0.15; // å¢å¼ºXè½´åé¦ˆ
                            this.showcaseCover.position.z += physics.position.z * 0.15; // å¢å¼ºZè½´åé¦ˆ
                            
                            // æ—‹è½¬å¼¹ç°§åé¦ˆï¼ˆæ”¯æŒä¸Šä¸‹åè½¬ï¼‰
                            this.showcaseCover.rotation.x += physics.rotation.x * 0.15; // å¢å¼ºXè½´æ—‹è½¬åé¦ˆ
                            this.showcaseCover.rotation.y += physics.rotation.y * 0.15; // å¢å¼ºYè½´æ—‹è½¬åé¦ˆ
                            this.showcaseCover.rotation.z += physics.rotation.z * 0.1;  // Zè½´æ—‹è½¬åé¦ˆ
                        } else {
                            // å¦‚æœæ²¡æœ‰ç‰©ç†å±æ€§ï¼Œåªåº”ç”¨åŸºç¡€æµ®åŠ¨
                            this.showcaseCover.position.y = floatingOffset;
                        }
                    }
                    */
                    
                    // æ¸²æŸ“åœºæ™¯
                    this.showcaseRenderer.render(this.showcaseScene, this.showcaseCamera);
                    
                    this.showcaseAnimationId = requestAnimationFrame(animate);
                };
                
                animate();
                console.log('å±•ç¤ºå°åŠ¨ç”»å¾ªç¯å¯åŠ¨');
            }
            
            // åœæ­¢å±•ç¤ºå°åŠ¨ç”»
            stopShowcaseAnimation() {
                if (this.showcaseAnimationId) {
                    cancelAnimationFrame(this.showcaseAnimationId);
                    this.showcaseAnimationId = null;
                }
                this.showcaseActive = false;
                console.log('å±•ç¤ºå°åŠ¨ç”»åœæ­¢');
            }
            
            // åˆå§‹åŒ–3Då±•ç¤ºå°ï¼ˆå®Œæ•´æµç¨‹ï¼‰
            initializeShowcase(albumPath) {
                try {
                    console.log('å¼€å§‹åˆå§‹åŒ–3Då±•ç¤ºå°:', albumPath);
                    
                    // æ£€æŸ¥Canvaså…ƒç´ æ˜¯å¦å­˜åœ¨
                    const canvas = document.getElementById('album-showcase-canvas');
                    if (!canvas) {
                        console.error('æ‰¾ä¸åˆ°å±•ç¤ºå°Canvaså…ƒç´ ');
                        return;
                    }
                    
                    // åˆå§‹åŒ–åœºæ™¯
                    this.initShowcaseScene();
                    
                    // åˆ›å»ºå±•ç¤ºå°
                    this.createShowcaseStand();
                    
                    // è®¾ç½®å…‰ç…§
                    this.setupShowcaseLights();
                    
                    // åˆ›å»ºå°é¢ï¼ˆå¦‚æœæœ‰ä¸“è¾‘è·¯å¾„ï¼‰
                    if (albumPath) {
                        this.createShowcaseCover(albumPath);
                    }
                    
                    // åˆå§‹åŒ–ç‰©ç†å±æ€§ç”¨äºç£æ‚¬æµ®æ™ƒåŠ¨æ•ˆæœ
                    if (this.showcaseCover) {
                        // æ·»åŠ ç‰©ç†å±æ€§
                        this.showcaseCover.userData.physics = {
                            position: new THREE.Vector3(0, 0, 0),
                            velocity: new THREE.Vector3(0, 0, 0),
                            acceleration: new THREE.Vector3(0, 0, 0),
                            rotation: new THREE.Vector3(0, 0, 0),
                            angularVelocity: new THREE.Vector3(0, 0, 0),
                            angularAcceleration: new THREE.Vector3(0, 0, 0),
                            isShaking: false,
                            shakeStartTime: 0,
                            shakeIntensity: 0
                        };
                        
                        // è°ƒæ•´æ™ƒåŠ¨å‚æ•°ï¼Œå‡å¼±å¼¹ç°§å›å¼¹æ•ˆæœï¼Œå¢åŠ é˜»å°¼ç¨³å®šæ€§
                        this.showcaseCover.userData.shakeParams = {
                            springConstant: 2.0,    // é™ä½å¼¹ç°§å¸¸æ•°ï¼Œå‡å°‘å›å¼¹å¼ºåº¦
                            damping: 0.25,          // å¢åŠ é˜»å°¼ç³»æ•°ï¼Œå¿«é€Ÿç¨³å®š
                            mass: 1.0,              // è´¨é‡ä¿æŒä¸å˜
                            maxShakeIntensity: 0.8  // é™ä½æœ€å¤§æ™ƒåŠ¨å¼ºåº¦
                        };
                    }
                    
                    // è®¾ç½®é¼ æ ‡äº¤äº’
                    this.setupShowcaseMouseInteraction();
                    
                    // å·²ç§»é™¤ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
                    
                    // å¯åŠ¨åŠ¨ç”»å¾ªç¯
                    this.showcaseActive = true;
                    this.startShowcaseAnimation();
                    
                    console.log('3Då±•ç¤ºå°åˆå§‹åŒ–å®Œæˆ');
                    
                } catch (error) {
                    console.error('3Då±•ç¤ºå°åˆå§‹åŒ–å¤±è´¥:', error);
                    // å¤±è´¥æ—¶æ¸…ç†èµ„æº
                    this.cleanupShowcase();
                }
            }
            
            // æ¸…ç†å±•ç¤ºå°èµ„æº
            cleanupShowcase() {
                try {
                    console.log('å¼€å§‹æ¸…ç†å±•ç¤ºå°èµ„æº');
                    
                    // åœæ­¢åŠ¨ç”»å¾ªç¯
                    this.stopShowcaseAnimation();
                    
                    // æ¸…ç†å…¨å±é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
                    if (this.showcaseMouseMoveHandler) {
                        document.removeEventListener('mousemove', this.showcaseMouseMoveHandler);
                        this.showcaseMouseMoveHandler = null;
                    }
                    
                    if (this.showcaseMouseIdleHandler) {
                        document.removeEventListener('mousemove', this.showcaseMouseIdleHandler);
                        this.showcaseMouseIdleHandler = null;
                    }
                    
                    // æ¸…ç†ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
                    const canvas = document.getElementById('album-showcase-canvas');
                    if (canvas) {
                        canvas.removeEventListener('click', this.showcaseClickHandler);
                    }
                    
                    // æ¸…ç†é¼ æ ‡é™æ­¢å®šæ—¶å™¨
                    if (this.mouseIdleTimer) {
                        clearTimeout(this.mouseIdleTimer);
                        this.mouseIdleTimer = null;
                    }
                    
                    // æ¸…ç†å°é¢èµ„æº
                    if (this.showcaseCover) {
                        // æ¸…ç†ç‰©ç†å±æ€§
                        if (this.showcaseCover.userData.physics) {
                            this.showcaseCover.userData.physics = null;
                        }
                        if (this.showcaseCover.userData.shakeParams) {
                            this.showcaseCover.userData.shakeParams = null;
                        }
                        
                        // æ¸…ç†çº¹ç†
                        if (this.showcaseCover.material.map) {
                            this.showcaseCover.material.map.dispose();
                        }
                        // æ¸…ç†æè´¨
                        this.showcaseCover.material.dispose();
                        // æ¸…ç†å‡ ä½•ä½“
                        this.showcaseCover.geometry.dispose();
                        // ä»åœºæ™¯ä¸­ç§»é™¤
                        if (this.showcaseScene && this.showcaseCover.parent) {
                            this.showcaseScene.remove(this.showcaseCover);
                        }
                        this.showcaseCover = null;
                    }
                    
                    // æ¸…ç†å±•ç¤ºå°èµ„æº
                    if (this.showcaseStand) {
                        this.showcaseStand.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                        if (this.showcaseScene) {
                            this.showcaseScene.remove(this.showcaseStand);
                        }
                        this.showcaseStand = null;
                    }
                    
                    // æ¸…ç†ç¯å…‰èµ„æº
                    this.showcaseLights.forEach(light => {
                        if (this.showcaseScene) {
                            this.showcaseScene.remove(light);
                            // æ¸…ç†å®šå‘å…‰çš„target
                            if (light.target && light.target.parent) {
                                this.showcaseScene.remove(light.target);
                            }
                        }
                    });
                    this.showcaseLights = [];
                    
                    // æ¸…ç†æ¸²æŸ“å™¨
                    if (this.showcaseRenderer) {
                        this.showcaseRenderer.dispose();
                        this.showcaseRenderer = null;
                    }
                    
                    // æ¸…ç†åœºæ™¯
                    if (this.showcaseScene) {
                        // é€’å½’æ¸…ç†åœºæ™¯ä¸­çš„æ‰€æœ‰å¯¹è±¡
                        this.showcaseScene.traverse((object) => {
                            if (object.geometry) {
                                object.geometry.dispose();
                            }
                            if (object.material) {
                                if (Array.isArray(object.material)) {
                                    object.material.forEach(material => material.dispose());
                                } else {
                                    object.material.dispose();
                                }
                            }
                        });
                        this.showcaseScene = null;
                    }
                    
                    // é‡ç½®ç›¸æœº
                    this.showcaseCamera = null;
                    
                    // é‡ç½®çŠ¶æ€
                    this.showcaseActive = false;
                    this.mousePosition = { x: 0, y: 0 };
                    
                    console.log('å±•ç¤ºå°èµ„æºæ¸…ç†å®Œæˆ');
                    
                } catch (error) {
                    console.error('æ¸…ç†å±•ç¤ºå°èµ„æºæ—¶å‡ºé”™:', error);
                    // å¼ºåˆ¶é‡ç½®çŠ¶æ€
                    this.showcaseActive = false;
                    this.showcaseScene = null;
                    this.showcaseCamera = null;
                    this.showcaseRenderer = null;
                    this.showcaseCover = null;
                    this.showcaseStand = null;
                    this.showcaseLights = [];
                    this.mousePosition = { x: 0, y: 0 };
                }
            }

            createGrid() {
                this.calculateGridLayout();

                // é‡ç½®å·²ä½¿ç”¨çš„ä¸“è¾‘åˆ—è¡¨
                this.usedAlbums = [];

                // ä½¿ç”¨Math.ceilç¡®ä¿è¦†ç›–æ•´ä¸ªå±å¹•ï¼ŒåŒ…æ‹¬éƒ¨åˆ†æ˜¾ç¤ºçš„å°é¢
                const totalColumns = Math.ceil(this.gridCols);
                const totalCovers = this.gridRows * totalColumns;
                console.log(`å¼€å§‹åˆ›å»ºç½‘æ ¼: ${this.gridRows}x${totalColumns} = ${totalCovers} ä¸ªå°é¢`);
                console.log(`å¯ç”¨ä¸“è¾‘æ•°é‡: ${this.albums.length}`);

                if (totalCovers > this.albums.length) {
                    console.log(`éœ€è¦é‡å¤ä½¿ç”¨ ${totalCovers - this.albums.length} ä¸ªå°é¢`);
                } else {
                    console.log(`ä¸“è¾‘æ•°é‡è¶³å¤Ÿï¼Œæ— éœ€é‡å¤`);
                }

                for (let row = 0; row < this.gridRows; row++) {
                    for (let col = 0; col < totalColumns; col++) {
                        const x = this.startX + col * (this.coverSize + this.gap) + this.coverSize / 2;
                        const y = this.startY - row * (this.coverSize + this.gap) - this.coverSize / 2;

                        this.createCover(x, y, row, col);
                    }
                }

                // console.log(`ç½‘æ ¼åˆ›å»ºå®Œæˆï¼Œå®é™…ä½¿ç”¨äº† ${this.usedAlbums.length} ä¸ªä¸åŒçš„ä¸“è¾‘`);
            }

            calculateGridLayout() {
                // è·å–ç›¸æœºçš„å¯è§†åŒºåŸŸ
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = this.frustumSize;
                const viewWidth = frustumSize * aspect;
                const viewHeight = frustumSize;

                // æ ¹æ®è®¾ç½®çš„è¡Œæ•°è®¡ç®—å°é¢å¤§å°
                // å°é¢å¤§å° = (è§†å£é«˜åº¦ - (è¡Œæ•°-1) * é—´éš™) / è¡Œæ•°
                this.coverSize = (viewHeight - (this.gridRows - 1) * this.gap) / this.gridRows;
                
                // è®¡ç®—èƒ½å®¹çº³çš„åˆ—æ•°ï¼ˆå¯èƒ½æ˜¯å°æ•°ï¼Œè¿™æ ·ä¸¤ä¾§å¯èƒ½ä¼šå‡ºç°ä¸è¶³ä¸€ä¸ªå°é¢çš„æƒ…å†µï¼‰
                this.gridCols = viewWidth / (this.coverSize + this.gap);
                
                // è®¡ç®—å®é™…ä½¿ç”¨çš„æ€»å°ºå¯¸
                const actualWidth = Math.ceil(this.gridCols) * (this.coverSize + this.gap) - this.gap;
                const actualHeight = this.gridRows * this.coverSize + (this.gridRows - 1) * this.gap;

                // è®¡ç®—èµ·å§‹ä½ç½®ä»¥å±…ä¸­æ˜¾ç¤º
                this.startX = -actualWidth / 2;
                this.startY = actualHeight / 2;

                // console.log(`ç½‘æ ¼å¸ƒå±€: ${this.gridCols.toFixed(2)}x${this.gridRows}, å°é¢å¤§å°: ${this.coverSize.toFixed(3)}, é—´éš™: ${this.gap}`);
                // console.log(`è§†å›¾å°ºå¯¸: ${viewWidth.toFixed(2)} x ${viewHeight.toFixed(2)}`);
                // console.log(`å®é™…å°ºå¯¸: ${actualWidth.toFixed(2)} x ${actualHeight.toFixed(2)}`);
            }

            recalculateGrid() {
                // æ¸…é™¤ç°æœ‰çš„å°é¢
                this.covers.forEach(cover => {
                    this.scene.remove(cover);
                });
                this.covers = [];

                // æ ‡è®°ä¸ºé‡æ–°åˆå§‹åŒ–çŠ¶æ€
                this.isInitializing = true;

                // é‡æ–°åˆ›å»ºç½‘æ ¼
                this.createGrid();

                // é‡æ–°åˆå§‹åŒ–å®Œæˆ
                this.isInitializing = false;
            }

            createCover(x, y, row, col) {
                // åˆ›å»ºå‡ ä½•ä½“ - ä½¿ç”¨è®¡ç®—å‡ºçš„å°é¢å¤§å°
                const geometry = new THREE.PlaneGeometry(this.coverSize, this.coverSize);

                // åŠ è½½éšæœºä¸“è¾‘å°é¢çº¹ç†
                const albumPath = this.getRandomAlbum();
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load(albumPath, (loadedTexture) => {
                    // å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œè°ƒæ•´çº¹ç†ä»¥å®ç° object-fit: cover æ•ˆæœ
                    this.adjustTextureForCover(loadedTexture);
                });

                // åˆ›å»ºæè´¨
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                // åˆ›å»ºç½‘æ ¼
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, 0);

                // å­˜å‚¨ç½‘æ ¼ä¿¡æ¯
                mesh.userData = {
                    row: row,
                    col: col,
                    index: row * this.gridCols + col,
                    albumPath: albumPath,
                    originalPosition: { x, y, z: 0 },
                    originalRotation: { x: 0, y: 0, z: 0 }
                };

                this.scene.add(mesh);
                this.covers.push(mesh);
            }

            getRandomAlbum() {
                // æ£€æŸ¥ä¸“è¾‘æ•°ç»„æ˜¯å¦ä¸ºç©º
                if (this.albums.length === 0) {
                    // å¦‚æœä¸“è¾‘æ•°ç»„ä¸ºç©ºï¼Œè¿”å›æœ¬åœ°coverç›®å½•ä¸‹çš„é»˜è®¤å›¾ç‰‡è·¯å¾„
                    const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');
                    const defaultImage = `${baseUrl}cover/1.jpg`;
                    return defaultImage;
                }
                
                if (this.isInitializing) {
                    // åˆå§‹åŒ–æ—¶ä¼˜å…ˆä½¿ç”¨ä¸åŒçš„å°é¢
                    return this.getUniqueAlbumForInitialization();
                } else {
                    // åŠ¨ç”»æ—¶ä½¿ç”¨å®Œå…¨éšæœºçš„å°é¢
                    return this.albums[Math.floor(Math.random() * this.albums.length)];
                }
            }

            getUniqueAlbumForInitialization() {
                // æ£€æŸ¥ä¸“è¾‘æ•°ç»„æ˜¯å¦ä¸ºç©º
                if (this.albums.length === 0) {
                    // å¦‚æœä¸“è¾‘æ•°ç»„ä¸ºç©ºï¼Œè¿”å›æœ¬åœ°coverç›®å½•ä¸‹çš„é»˜è®¤å›¾ç‰‡è·¯å¾„
                    const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');
                    const defaultImage = `${baseUrl}cover/1.jpg`;
                    return defaultImage;
                }
                
                // å¦‚æœè¿˜æœ‰æœªä½¿ç”¨çš„ä¸“è¾‘ï¼Œä¼˜å…ˆé€‰æ‹©
                if (this.usedAlbums.length < this.albums.length) {
                    let albumIndex;
                    do {
                        albumIndex = Math.floor(Math.random() * this.albums.length);
                    } while (this.usedAlbums.includes(albumIndex));

                    this.usedAlbums.push(albumIndex);

                    // åªåœ¨å‰å‡ ä¸ªå’Œè¾¾åˆ°é‡Œç¨‹ç¢‘æ—¶è¾“å‡ºæ—¥å¿—
                    if (this.usedAlbums.length <= 5 || this.usedAlbums.length % 10 === 0) {
                        const fileName = this.albums[albumIndex].split('/').pop();
                        console.log(`âœ“ æ–°å°é¢ ${this.usedAlbums.length}/${this.albums.length}: ${fileName}`);
                    }

                    return this.albums[albumIndex];
                } else {
                    // æ‰€æœ‰ä¸“è¾‘éƒ½ç”¨è¿‡äº†ï¼Œå¼€å§‹é‡å¤ä½¿ç”¨
                    const albumIndex = Math.floor(Math.random() * this.albums.length);

                    // ç¬¬ä¸€æ¬¡å¼€å§‹é‡å¤æ—¶è¾“å‡ºæç¤º
                    if (this.usedAlbums.length === this.albums.length) {
                        console.log(`ğŸ“‹ æ‰€æœ‰ ${this.albums.length} ä¸ªä¸åŒå°é¢å·²ä½¿ç”¨å®Œï¼Œå¼€å§‹é‡å¤ä½¿ç”¨`);
                        this.usedAlbums.push(-1); // æ ‡è®°å·²å¼€å§‹é‡å¤
                    }

                    return this.albums[albumIndex];
                }
            }

            // è°ƒæ•´çº¹ç†ä»¥å®ç° object-fit: cover æ•ˆæœ
            adjustTextureForCover(texture) {
                const image = texture.image;
                if (!image || !image.width || !image.height) {
                    return;
                }

                const imageAspect = image.width / image.height;

                if (imageAspect !== 1) { // ä¸æ˜¯æ­£æ–¹å½¢
                    // è®¡ç®—è£åˆ‡å‚æ•°ä»¥å®ç°å±…ä¸­è£åˆ‡
                    if (imageAspect > 1) {
                        // å®½å›¾ï¼šè£åˆ‡å·¦å³ä¸¤è¾¹
                        const cropWidth = image.height; // ä½¿ç”¨é«˜åº¦ä½œä¸ºè£åˆ‡å®½åº¦
                        const offsetX = (image.width - cropWidth) / 2 / image.width;

                        texture.offset.x = offsetX;
                        texture.repeat.x = cropWidth / image.width;
                        texture.offset.y = 0;
                        texture.repeat.y = 1;
                    } else {
                        // é«˜å›¾ï¼šè£åˆ‡ä¸Šä¸‹ä¸¤è¾¹
                        const cropHeight = image.width; // ä½¿ç”¨å®½åº¦ä½œä¸ºè£åˆ‡é«˜åº¦
                        const offsetY = (image.height - cropHeight) / 2 / image.height;

                        texture.offset.x = 0;
                        texture.repeat.x = 1;
                        texture.offset.y = offsetY;
                        texture.repeat.y = cropHeight / image.height;
                    }

                    texture.needsUpdate = true;
                }
            }

            startAnimations() {
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                }
                
                this.animationInterval = setInterval(() => {
                    this.triggerRandomAnimation();
                }, Math.random() * 1000 + this.animationIntervalTime);
            }

            triggerRandomAnimation() {
                // é€‰æ‹©ä¸€ç§åŠ¨ç”»ç±»å‹
                const animations = ['flip', 'drop', 'linkedDrop', 'rollDrop', 'pinRotation', 'rowRollDrop', 'rowDrop'];
                const weights = [
                    this.animationWeights.flip,
                    this.animationWeights.drop,
                    this.animationWeights.linkedDrop,
                    this.animationWeights.rollDrop,
                    this.animationWeights.pinRotation,
                    this.animationWeights.rowRollDrop,
                    this.animationWeights.rowDrop
                ];
                const selectedAnimation = this.getWeightedRandomAnimation(animations, weights);
                
                // å¯¹äºè¡ŒåŠ¨ç”»ç±»å‹ï¼Œç›´æ¥æ‰§è¡Œè¡ŒåŠ¨ç”»
                if (selectedAnimation === 'rowRollDrop' || selectedAnimation === 'rowDrop') {
                    this.playAnimation(null, selectedAnimation);
                    return;
                }
                
                // å¯¹äºæ™®é€šåŠ¨ç”»ï¼Œéšæœºé€‰æ‹©3-6ä¸ªå°é¢
                const animationCount = Math.floor(Math.random() * 4) + 3;

                // éšæœºé€‰æ‹©å°é¢ï¼Œç¡®ä¿ä¸é‡å¤
                const selectedCovers = [];
                const availableCovers = [...this.covers];

                for (let i = 0; i < animationCount && availableCovers.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * availableCovers.length);
                    selectedCovers.push(availableCovers.splice(randomIndex, 1)[0]);
                }

                // åºåˆ—è§¦å‘åŠ¨ç”»
                selectedCovers.forEach((cover, index) => {
                    setTimeout(() => {
                        this.playAnimation(cover, selectedAnimation);
                    }, index * 200);
                });
            }

            getWeightedRandomAnimation(animations, weights) {
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                let random = Math.random() * totalWeight;

                for (let i = 0; i < animations.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        return animations[i];
                    }
                }

                return animations[0];
            }

            playAnimation(cover, type) {
                switch (type) {
                    case 'flip':
                        this.playFlipAnimation(cover);
                        break;
                    case 'drop':
                        this.playDropAnimation(cover);
                        break;
                    case 'linkedDrop':
                        this.playLinkedDropAnimation(cover);
                        break;
                    case 'rollDrop':
                        this.playRollDropAnimation(cover);
                        break;
                    case 'pinRotation':
                        this.playPinRotationAnimation(cover);
                        break;
                    case 'rowRollDrop':
                        this.playRowRollDropAnimation();
                        break;
                    case 'rowDrop':
                        this.playRowDropAnimation();
                        break;
                }
            }

            playFlipAnimation(cover) {
                // æ£€æŸ¥å°é¢æ˜¯å¦æ­£åœ¨è¿›è¡Œå…¶ä»–åŠ¨ç”»
                if (cover.userData.isAnimating) {
                    console.log('å°é¢æ­£åœ¨åŠ¨ç”»ä¸­ï¼Œè·³è¿‡ç¿»è½¬åŠ¨ç”»');
                    return;
                }

                // æ ‡è®°ä¸ºåŠ¨ç”»ä¸­
                cover.userData.isAnimating = true;

                // é€‰æ‹©ä¸€ä¸ªä¸åŒäºå½“å‰çš„ä¸“è¾‘ä½œä¸ºâ€œèƒŒé¢/ç¿»è¿‡æ¥åâ€çš„æ–°å°é¢
                const currentAlbum = cover.userData.albumPath;
                let newAlbum = this.getRandomAlbum();
                let tries = 0;
                while (newAlbum === currentAlbum && tries < 8) {
                    newAlbum = this.getRandomAlbum();
                    tries++;
                }

                // å…ˆåŠ è½½å¥½æ–°çº¹ç†ï¼ŒåŠ è½½å®Œæˆåå†å¼€å§‹ç¿»è½¬ï¼ˆé¿å…ä¸­é€”åˆ‡è´´å›¾é€ æˆé¡¿æŒ«ï¼‰
                const loader = new THREE.TextureLoader();
                loader.load(
                    newAlbum,
                    (newTexture) => {
                        // è°ƒæ•´çº¹ç†ä»¥å®ç°æ­£æ–¹å½¢è£åˆ‡
                        this.adjustTextureForCover(newTexture);
                        // åˆ›å»ºâ€œæ­£åä¸¤é¢â€ç»“æ„ï¼šç”¨ä¸€ä¸ªä¸´æ—¶ Group æ‰¿è½½ä¸¤å¼ é¢
                        const flipGroup = new THREE.Group();
                        flipGroup.position.copy(cover.position);
                        flipGroup.rotation.set(0, 0, 0);

                        // æŠŠåŸ cover ä½œä¸ºâ€œæ­£é¢â€æ”¾è¿›ç»„é‡Œï¼Œå¹¶å°†å…¶å±€éƒ¨å˜æ¢é‡ç½®
                        const oldSide = cover.material.side;
                        cover.material.side = THREE.FrontSide; // æ­£é¢åªæ¸²æŸ“æœå‘æ‘„åƒæœºçš„ä¸€é¢
                        cover.position.set(0, 0, 0);
                        cover.rotation.set(0, 0, 0);
                        flipGroup.add(cover);

                        // åˆ›å»ºâ€œèƒŒé¢â€ï¼šå‡ ä½•ä½“ç»•Yè½´æ—‹è½¬180Â°ï¼Œè¿™æ ·åœ¨æ—‹è½¬è¿‡åŠåæ˜¾ç¤ºä¸ºæ­£å‘ã€æ— é•œåƒ
                        const backGeometry = new THREE.PlaneGeometry(this.coverSize, this.coverSize);
                        backGeometry.rotateY(Math.PI);
                        const backMaterial = new THREE.MeshBasicMaterial({
                            map: newTexture,
                            transparent: true,
                            side: THREE.FrontSide
                        });
                        const backMesh = new THREE.Mesh(backGeometry, backMaterial);
                        backMesh.position.set(0, 0, 0);
                        flipGroup.add(backMesh);

                        // å°†ç»„åŠ å…¥åœºæ™¯ï¼Œå¹¶ä¸´æ—¶ä»åœºæ™¯ä¸­ç§»é™¤ coverï¼ˆä½† covers æ•°ç»„å¼•ç”¨ä¿æŒä¸å˜ï¼‰
                        this.scene.add(flipGroup);
                        this.scene.remove(cover);

                        // åŠ¨ç”»å‚æ•° + ç¼“åŠ¨
                        const duration = 900;
                        const startTime = Date.now();
                        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

                        const animate = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = easeInOutSine(progress);

                            // å›´ç»•ä¸–ç•ŒZè½´å‚ç›´çš„è‡ªèº«Yè½´ç¿»è½¬
                            flipGroup.rotation.y = eased * Math.PI;

                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else {
                                // ç¿»è½¬å®Œæˆï¼šå°†åŸ cover çš„è´´å›¾æ›´æ–°ä¸ºæ–°å°é¢
                                cover.material.map = newTexture;
                                cover.material.needsUpdate = true;
                                cover.userData.albumPath = newAlbum;

                                // ä»ç»„é‡Œå–å› coverï¼Œæ¢å¤åˆ°åŸä½ç½®ä¸æ—‹è½¬åŸºçº¿
                                cover.position.copy(flipGroup.position);
                                cover.rotation.set(0, 0, 0);

                                // æ¸…ç†ä¸´æ—¶å¯¹è±¡
                                this.scene.remove(flipGroup);
                                this.scene.add(cover);
                                backGeometry.dispose();
                                backMaterial.dispose();

                                // æ¢å¤åŸæœ‰çš„ side è®¾ç½®
                                cover.material.side = oldSide;

                                // ç»“æŸåŠ¨ç”»æ ‡è®°
                                cover.userData.isAnimating = false;
                            }
                        };

                        animate();
                    },
                    undefined,
                    (err) => {
                        console.warn('ç¿»è½¬æ–°çº¹ç†åŠ è½½å¤±è´¥:', err);
                        cover.userData.isAnimating = false;
                    }
                );
            }

            playDropAnimation(cover) {
                // æ£€æŸ¥å°é¢æ˜¯å¦æ­£åœ¨è¿›è¡Œå…¶ä»–åŠ¨ç”»
                if (cover.userData.isAnimating) {
                    console.log('å°é¢æ­£åœ¨åŠ¨ç”»ä¸­ï¼Œè·³è¿‡æ‰è½åŠ¨ç”»');
                    return;
                }

                // æ ‡è®°ä¸ºåŠ¨ç”»ä¸­
                cover.userData.isAnimating = true;

                // ä¿å­˜å½“å‰çŠ¶æ€
                const originalX = cover.position.x;
                const originalY = cover.position.y;
                const originalZ = cover.position.z;
                const currentAlbum = cover.userData.albumPath;

                // é¢„å…ˆå‡†å¤‡æ–°å°é¢ - åœ¨åŠ¨ç”»å¼€å§‹å‰å°±åˆ›å»ºå¹¶æ”¾ç½®åœ¨åŸä½ç½®
                const newAlbum = this.getRandomAlbum();
                const textureLoader = new THREE.TextureLoader();
                const newTexture = textureLoader.load(newAlbum, (loadedTexture) => {
                    this.adjustTextureForCover(loadedTexture);
                });

                // åˆ›å»ºæ–°å°é¢å‡ ä½•ä½“å’Œæè´¨
                const newGeometry = new THREE.PlaneGeometry(this.coverSize, this.coverSize);
                const newMaterial = new THREE.MeshBasicMaterial({
                    map: newTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                // åˆ›å»ºæ–°å°é¢ç½‘æ ¼ï¼Œæ”¾åœ¨åŸå°é¢åé¢ï¼ˆzè½´ç¨å¾®é åï¼‰
                const newCover = new THREE.Mesh(newGeometry, newMaterial);
                newCover.position.set(originalX, originalY, -0.01);
                newCover.userData = {
                    row: cover.userData.row,
                    col: cover.userData.col,
                    index: cover.userData.index,
                    albumPath: newAlbum,
                    originalPosition: { ...cover.userData.originalPosition },
                    originalRotation: { ...cover.userData.originalRotation }
                };
                this.scene.add(newCover);

                // ä½¿ç”¨â€œä¸­å¿ƒXè½´ï¼ˆä¸Šä¸‹è¾¹ä¸­çº¿ï¼‰â€ä½œä¸ºæ¢è½´ï¼Œè¿›è¡Œç«‹ä½“æ—‹è½¬å¹¶è‡ªç„¶ä¸‹å 
                const pivot = new THREE.Group();
                pivot.position.set(originalX, originalY, originalZ);
                this.scene.add(pivot);

                // ç”± pivot æ§åˆ¶æ—‹è½¬/ä½ç§»ï¼›cover åœ¨å±€éƒ¨åæ ‡ä¿æŒå±…ä¸­
                cover.rotation.set(0, 0, 0);
                cover.position.set(0, 0, 0);
                pivot.add(cover);

                // åŠ¨ç”»å‚æ•°
                const frustumSize = 20;
                const viewHeight = frustumSize;
                const finalPivotY = -viewHeight / 2 - this.coverSize; // æœ€ç»ˆè½åˆ°å±å¹•åº•éƒ¨ä¹‹å¤–
                const duration = 2200; // å¢åŠ æŒç»­æ—¶é—´ï¼Œè®©åŠ¨ç”»æ›´è‡ªç„¶
                const startTime = Date.now();


                // ç‰©ç†å‚æ•°
                const gravity = 9.8; // é‡åŠ›åŠ é€Ÿåº¦ï¼ˆç›¸å¯¹å•ä½ï¼‰
                const initialVelocityY = 0; // åˆå§‹å‚ç›´é€Ÿåº¦
                const airResistance = 0.02; // ç©ºæ°”é˜»åŠ›ç³»æ•°
                const terminalVelocity = 8; // ç»ˆç«¯é€Ÿåº¦
                // éšæœºä¸€äº›ä¸‰ç»´å§¿æ€å‚æ•°ï¼Œè®©æ‰è½ä¸æ˜¾å¾—â€œå‹æ‰â€
                const yawTarget = (Math.random() * 0.8 - 0.4); // ç»•Yè½´çš„ç›®æ ‡åèˆªï¼Œ-23Â°~23Â°
                const zForward = Math.max(0.8, this.coverSize * 0.5); // å‘å±å¹•å†…å¤–æ¨è¿›çš„å¹…åº¦
                const rollWobble = (Math.random() * 0.3 - 0.15); // ç»•Zè½´çš„æŠ–åŠ¨
                const baseTiltX = 0.25; // ç¬¬ä¸€é˜¶æ®µå‰å€¾è§’

                // æ—‹è½¬å‚æ•° - æ”¹è¿›çš„ç‰©ç†æ¨¡æ‹Ÿ
                const initialRotationSpeed = 0.5; // åˆå§‹æ—‹è½¬é€Ÿåº¦ï¼ˆå¼§åº¦/ç§’ï¼‰
                const rotationAcceleration = 2.5; // æ—‹è½¬åŠ é€Ÿåº¦
                const maxRotationSpeed = 12; // æœ€å¤§æ—‹è½¬é€Ÿåº¦
                const rotationAxis = Math.random() > 0.5 ? 1 : -1; // éšæœºæ—‹è½¬æ–¹å‘

                const zClearance = 0.08; // ä¸â€œå¢™â€çš„æœ€å°å‰å‘é—´è·

                // æ”¹è¿›çš„ç¼“åŠ¨å‡½æ•°
                const easeInQuart = (t) => t * t * t * t;
                const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
                const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    if (progress <= 0.2) {
                        // é˜¶æ®µ1ï¼šå‡†å¤‡é˜¶æ®µ - è½»å¾®å‰å€¾å’Œåˆ†ç¦»
                        const p = progress / 0.2;
                        const tilt = p * baseTiltX;

                        pivot.rotation.x = tilt * easeOutQuart(p);
                        pivot.rotation.y = yawTarget * (0.3 * easeInOutCubic(p));
                        pivot.rotation.z = rollWobble * 0.2 * Math.sin(p * Math.PI);

                        // è½»å¾®ä¸Šå‡ç„¶åå¼€å§‹ä¸‹è½
                        const lift = Math.sin(p * Math.PI) * 0.1;
                        pivot.position.y = originalY + lift;

                        // Zè½´åˆ†ç¦»
                        const half = this.coverSize / 2;
                        const minZ = zClearance + half * Math.abs(Math.sin(tilt));
                        const baseZ = originalZ + p * 0.2;
                        pivot.position.z = Math.max(baseZ, minZ);
                    } else {
                        // é˜¶æ®µ2ï¼šç»•ä¸­å¿ƒXè½´æŒç»­æ—‹è½¬ + åèˆªå®Œæˆ + ä¸‹å  + è½»å¾®æ»šåŠ¨æŠ–åŠ¨
                        const p = (progress - 0.2) / 0.8;
                        const fallTime = p * (duration * 0.8 / 1000); // æ‰è½æ—¶é—´ï¼ˆç§’ï¼‰

                        // æ”¹è¿›çš„é‡åŠ›æ¨¡æ‹Ÿ
                        let velocityY = initialVelocityY + gravity * fallTime;
                        // åº”ç”¨ç©ºæ°”é˜»åŠ›
                        velocityY = Math.min(velocityY * (1 - airResistance * fallTime), terminalVelocity);

                        // æ”¹è¿›çš„æ—‹è½¬ç‰©ç†æ¨¡æ‹Ÿ
                        let currentRotationSpeed = initialRotationSpeed + rotationAcceleration * fallTime;
                        currentRotationSpeed = Math.min(currentRotationSpeed, maxRotationSpeed);

                        // æ—‹è½¬è§’åº¦ç´¯ç§¯
                        const totalRotation = (initialRotationSpeed * fallTime + 0.5 * rotationAcceleration * fallTime * fallTime) * rotationAxis;
                        pivot.rotation.x = baseTiltX + totalRotation;

                        // Yè½´åèˆªæ¸è¿›åˆ°ç›®æ ‡ï¼Œé¿å…ä»…â€œå‹æ‰â€è§†è§‰
                        const yawProgress = easeInOutCubic(Math.min(p * 1.5, 1));
                        pivot.rotation.y = yawTarget * (0.3 + 0.7 * yawProgress);

                        // Zè½´æŠ–åŠ¨ - æ¨¡æ‹Ÿç©ºæ°”æ¹æµ
                        const turbulence = Math.sin(fallTime * 8) * Math.cos(fallTime * 3) * 0.1;
                        pivot.rotation.z = rollWobble * (Math.sin(p * Math.PI * 2) + turbulence) * Math.min(p * 2, 1);

                        // ä½¿ç”¨ç‰©ç†å…¬å¼è®¡ç®—ä½ç½®ï¼šs = vâ‚€t + Â½gtÂ²
                        const fallDistance = initialVelocityY * fallTime + 0.5 * gravity * fallTime * fallTime;
                        // åº”ç”¨ç©ºæ°”é˜»åŠ›ä¿®æ­£
                        const resistanceModifier = 1 - Math.min(airResistance * fallTime, 0.3);
                        const actualFallDistance = fallDistance * resistanceModifier;

                        pivot.position.y = originalY - actualFallDistance * (Math.abs(originalY - finalPivotY) / 10);

                        // Zè½´æ¨è¿› - å¢å¼ºé€è§†æ•ˆæœ
                        const half = this.coverSize / 2;
                        const baseZ = originalZ + 0.2 + easeInQuart(p) * zForward;
                        const minZ = zClearance + half * Math.abs(Math.sin(pivot.rotation.x));
                        pivot.position.z = Math.max(baseZ, minZ);

                        // æ”¹è¿›çš„æ·¡å‡ºæ•ˆæœ
                        if (p > 0.6) {
                            const fadeStart = 0.6;
                            const fadeProgress = (p - fadeStart) / (1 - fadeStart);
                            const opacity = 1 - easeInQuart(fadeProgress);
                            cover.material.opacity = Math.max(0, opacity);
                        }

                        // è½»å¾®çš„å°ºå¯¸å˜åŒ–æ¨¡æ‹Ÿè·ç¦»æ„Ÿ
                        const scaleEffect = 1 + easeInQuart(p) * 0.15;
                        cover.scale.set(scaleEffect, scaleEffect, scaleEffect);
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // åŠ¨ç”»ç»“æŸï¼šç§»é™¤æ—§å°é¢ä¸æ¢è½´ç»„
                        pivot.remove(cover);
                        this.scene.remove(pivot);
                        this.scene.remove(cover);

                        // ç”¨æ–°å°é¢é¡¶æ›¿
                        newCover.position.z = 0;
                        const coverIndex = this.covers.indexOf(cover);
                        if (coverIndex !== -1) {
                            this.covers[coverIndex] = newCover;
                        }

                        // æ¸…é™¤åŠ¨ç”»æ ‡è®°
                        newCover.userData.isAnimating = false;
                    }
                };

                animate();
            }

            playLinkedDropAnimation(cover) {
                // æ‰¾åˆ°ä¸€ä¸ªè·ç¦»æ˜¯4çš„å€æ•°çš„ç›®æ ‡ä½ç½®
                const sourceIndex = cover.userData.index;
                const sourceRow = Math.floor(sourceIndex / this.gridCols);
                const sourceCol = sourceIndex % this.gridCols;

                // å¯»æ‰¾åˆé€‚çš„ç›®æ ‡ï¼šè·ç¦»æ˜¯4çš„å€æ•°
                const validTargets = [];

                for (const targetCover of this.covers) {
                    if (targetCover === cover) continue;

                    const targetIndex = targetCover.userData.index;
                    const targetRow = Math.floor(targetIndex / this.gridCols);
                    const targetCol = targetIndex % this.gridCols;

                    // è®¡ç®—æ›¼å“ˆé¡¿è·ç¦»
                    const distance = Math.abs(targetRow - sourceRow) + Math.abs(targetCol - sourceCol);

                    // åªé€‰æ‹©è·ç¦»æ˜¯4çš„å€æ•°çš„ç›®æ ‡ï¼Œä¸”åœ¨åˆç†èŒƒå›´å†…
                    if (distance % 4 === 0 && distance >= 4 && distance <= 12 && targetRow > sourceRow) {
                        validTargets.push({
                            cover: targetCover,
                            distance: distance,
                            row: targetRow,
                            col: targetCol
                        });
                    }
                }

                if (validTargets.length === 0) {
                    // å¦‚æœæ²¡æœ‰åˆé€‚çš„4å€æ•°è·ç¦»ç›®æ ‡ï¼Œæ‰§è¡Œæ™®é€šæ‰è½
                    console.log('æ²¡æœ‰æ‰¾åˆ°4å€æ•°è·ç¦»çš„ç›®æ ‡ï¼Œæ‰§è¡Œæ‰è½åŠ¨ç”»');
                    this.playDropAnimation(cover);
                    return;
                }

                // é€‰æ‹©ä¸€ä¸ªç›®æ ‡ï¼ˆä¼˜å…ˆé€‰æ‹©è·ç¦»è¾ƒè¿‘çš„ï¼‰
                validTargets.sort((a, b) => a.distance - b.distance);
                const selectedTarget = validTargets[Math.floor(Math.random() * Math.min(3, validTargets.length))];

                // console.log(`é€‰æ‹©ç›®æ ‡: è·ç¦»${selectedTarget.distance}æ­¥ (${selectedTarget.distance * 90}åº¦)`);

                // è®¡ç®—ç®€å•ç›´æ¥çš„è·¯å¾„
                const path = this.calculateDirectPath(sourceRow, sourceCol, selectedTarget.row, selectedTarget.col);

                // æ‰§è¡Œæ»šè½åŠ¨ç”»
                this.executeRollingAnimation(cover, selectedTarget.cover, path);
            }

            calculateDirectPath(sourceRow, sourceCol, targetRow, targetCol) {
                const path = [];
                let currentRow = sourceRow;
                let currentCol = sourceCol;

                // ç®€å•ç­–ç•¥ï¼šå…ˆæ°´å¹³ç§»åŠ¨ï¼Œå†å‚ç›´ç§»åŠ¨
                // å› ä¸ºæˆ‘ä»¬å·²ç»ç¡®ä¿äº†æ€»è·ç¦»æ˜¯4çš„å€æ•°ï¼Œæ‰€ä»¥ä¸éœ€è¦å¤æ‚çš„è°ƒæ•´

                // æ°´å¹³ç§»åŠ¨
                while (currentCol !== targetCol) {
                    if (currentCol < targetCol) {
                        currentCol++;
                    } else {
                        currentCol--;
                    }
                    path.push({
                        row: currentRow,
                        col: currentCol,
                        index: currentRow * this.gridCols + currentCol
                    });
                }

                // å‚ç›´ç§»åŠ¨
                while (currentRow !== targetRow) {
                    if (currentRow < targetRow) {
                        currentRow++;
                    } else {
                        currentRow--;
                    }
                    path.push({
                        row: currentRow,
                        col: currentCol,
                        index: currentRow * this.gridCols + currentCol
                    });
                }

                // console.log(`ç›´æ¥è·¯å¾„: ${path.length}æ­¥ (${path.length * 90}åº¦æ—‹è½¬)`);
                return path;
            }



            executeRollingAnimation(sourceCover, targetCover, path) {
                // æ£€æŸ¥å°é¢æ˜¯å¦æ­£åœ¨è¿›è¡Œå…¶ä»–åŠ¨ç”»
                if (sourceCover.userData.isAnimating || targetCover.userData.isAnimating) {
                    // console.log(`æ»šåŠ¨åŠ¨ç”»è·³è¿‡: æºå°é¢(${sourceCover.userData.row},${sourceCover.userData.col})åŠ¨ç”»çŠ¶æ€=${sourceCover.userData.isAnimating}, ç›®æ ‡å°é¢(${targetCover.userData.row},${targetCover.userData.col})åŠ¨ç”»çŠ¶æ€=${targetCover.userData.isAnimating}`);
                    return;
                }

                const sourceAlbum = sourceCover.userData.albumPath;

                // è®°å½•æºä½ç½®ç´¢å¼•ï¼Œä¾›ç»“æŸæ—¶æ›´æ–° covers æ•°ç»„
                const originalRow = sourceCover.userData.row;
                const originalCol = sourceCover.userData.col;
                const originalIndex = sourceCover.userData.index;

                // åœ¨ A ç‚¹ï¼ˆæºä½ç½®ï¼‰é¢„å…ˆåˆ›å»ºä¸€ä¸ªæ–°å°é¢ï¼Œé¿å…å‡ºç°é»‘è‰²é•‚ç©º
                const textureLoader = new THREE.TextureLoader();
                const newAlbumAtSource = this.getRandomAlbum();
                const newTextureAtSource = textureLoader.load(newAlbumAtSource, (loadedTexture) => {
                    this.adjustTextureForCover(loadedTexture);
                });

                const newGeometry = new THREE.PlaneGeometry(this.coverSize, this.coverSize);
                const newMaterialAtSource = new THREE.MeshBasicMaterial({
                    map: newTextureAtSource,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                const newSourceCover = new THREE.Mesh(newGeometry, newMaterialAtSource);
                newSourceCover.position.set(sourceCover.position.x, sourceCover.position.y, -0.01);
                newSourceCover.userData = {
                    row: originalRow,
                    col: originalCol,
                    index: originalIndex,
                    albumPath: newAlbumAtSource,
                    originalPosition: { ...sourceCover.userData.originalPosition },
                    originalRotation: { ...sourceCover.userData.originalRotation }
                };
                this.scene.add(newSourceCover);

                // è®¾ç½®åŠ¨ç”»çŠ¶æ€
                sourceCover.userData.isRolling = true;
                sourceCover.userData.isAnimating = true;
                targetCover.userData.isAnimating = true; // é”å®šç›®æ ‡ï¼Œé¿å…è¢«å…¶å®ƒåŠ¨ç”»å ç”¨

                // æå‡æ»šåŠ¨å°é¢çš„Zè½´å±‚çº§ï¼Œé¿å…ä¸å…¶ä»–å°é¢é‡å 
                sourceCover.position.z = 0.1;

                let totalRotation = 0;
                // ä½¿ç”¨ç²¾ç¡®çš„ç½‘æ ¼ä½ç½®ä½œä¸ºèµ·å§‹ä½ç½®
                let currentX = this.startX + originalCol * (this.coverSize + this.gap) + this.coverSize / 2;
                let currentY = this.startY - originalRow * (this.coverSize + this.gap) - this.coverSize / 2;
                const stepDuration = 300; // æ¯æ­¥çš„æŒç»­æ—¶é—´

                // åˆ›å»ºå®Œæ•´çš„è·¯å¾„ï¼ŒåŒ…æ‹¬èµ·å§‹ä½ç½®
                const fullPath = [
                    { row: originalRow, col: originalCol },
                    ...path
                ];

                let currentStep = 0;

                const animateStep = () => {
                    if (currentStep >= fullPath.length - 1) {
                        // åŠ¨ç”»å®Œæˆ
                        this.finishRollingAnimation(sourceCover, targetCover, newSourceCover, originalRow, originalCol, originalIndex, totalRotation);
                        return;
                    }

                    const currentPoint = fullPath[currentStep];
                    const nextPoint = fullPath[currentStep + 1];

                    // è®¡ç®—ç§»åŠ¨æ–¹å‘
                    const deltaRow = nextPoint.row - currentPoint.row;
                    const deltaCol = nextPoint.col - currentPoint.col;

                    // è®¡ç®—ç›®æ ‡ä½ç½® - ä½¿ç”¨ç²¾ç¡®çš„ç½‘æ ¼ä½ç½®
                    const targetGridX = this.startX + nextPoint.col * (this.coverSize + this.gap) + this.coverSize / 2;
                    const targetGridY = this.startY - nextPoint.row * (this.coverSize + this.gap) - this.coverSize / 2;

                    const targetX = targetGridX;
                    const targetY = targetGridY;

                    // è®¡ç®—æ—‹è½¬è§’åº¦ - æ­£æ–¹å½¢æ»šåŠ¨çš„æ­£ç¡®æ–¹å‘
                    let rotationIncrement = 0;
                    if (deltaCol > 0) {
                        // å‘å³æ»šåŠ¨ï¼šæ­£æ–¹å½¢å‘å‰æ»šåŠ¨ï¼ˆé¡ºæ—¶é’ˆï¼‰
                        rotationIncrement = -90; // æ³¨æ„ï¼šThree.jsä¸­Zè½´æ—‹è½¬ï¼Œè´Ÿå€¼æ˜¯é¡ºæ—¶é’ˆ
                    } else if (deltaCol < 0) {
                        // å‘å·¦æ»šåŠ¨ï¼šæ­£æ–¹å½¢å‘åæ»šåŠ¨ï¼ˆé€†æ—¶é’ˆï¼‰
                        rotationIncrement = 90;
                    } else if (deltaRow > 0) {
                        // å‘ä¸‹æ»šåŠ¨ï¼šæ­£æ–¹å½¢å‘å‰æ»šåŠ¨ï¼ˆé¡ºæ—¶é’ˆï¼‰
                        rotationIncrement = -90;
                    } else if (deltaRow < 0) {
                        // å‘ä¸Šæ»šåŠ¨ï¼šæ­£æ–¹å½¢å‘åæ»šåŠ¨ï¼ˆé€†æ—¶é’ˆï¼‰
                        rotationIncrement = 90;
                    }

                    totalRotation += rotationIncrement;

                    // æ‰§è¡Œæ»šåŠ¨åŠ¨ç”»
                    this.animateRollingStep(sourceCover, currentX, currentY, targetX, targetY, totalRotation, rotationIncrement, stepDuration);

                    // æ›´æ–°å½“å‰ä½ç½®
                    currentX = targetX;
                    currentY = targetY;

                    currentStep++;
                    setTimeout(animateStep, stepDuration);
                };

                // å¼€å§‹åŠ¨ç”»
                animateStep();
            }

            animateRollingStep(cover, startX, startY, targetX, targetY, finalRotation, rotationIncrement, duration) {
                const startTime = Date.now();
                const startRotation = finalRotation - rotationIncrement;

                // æ­£æ–¹å½¢æ»šåŠ¨ï¼šç®€åŒ–ç‰ˆæœ¬
                // æ­£æ–¹å½¢æ»šåŠ¨ä¸€æ ¼çš„è·ç¦»ç­‰äºè¾¹é•¿
                const sideLength = this.coverSize;

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©æ»šåŠ¨æ›´è‡ªç„¶
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                    // çº¿æ€§æ’å€¼ä½ç½®
                    const currentX = startX + (targetX - startX) * easeProgress;
                    const currentY = startY + (targetY - startY) * easeProgress;

                    // æ—‹è½¬è§’åº¦
                    const currentRotation = startRotation + rotationIncrement * easeProgress;

                    // æ»šåŠ¨æ—¶çš„è½»å¾®å¼§å½¢è½¨è¿¹
                    const arcHeight = sideLength * 0.1 * Math.sin(easeProgress * Math.PI);

                    // åº”ç”¨å˜æ¢
                    cover.position.x = currentX;
                    cover.position.y = currentY + arcHeight; // è½»å¾®çš„å¼§å½¢
                    cover.position.z = 0.1 + arcHeight * 0.5; // ä¿æŒåœ¨å…¶ä»–å°é¢ä¹‹ä¸Š
                    cover.rotation.z = currentRotation * Math.PI / 180;

                    // æ»šåŠ¨æ—¶è½»å¾®æ”¾å¤§
                    const scale = 1 + arcHeight / sideLength * 0.5;
                    cover.scale.set(scale, scale, scale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ç¡®ä¿æœ€ç»ˆçŠ¶æ€å‡†ç¡®ï¼Œç«‹å³é‡ç½®æ‰€æœ‰æ•ˆæœ
                        cover.position.x = targetX;
                        cover.position.y = targetY;
                        cover.position.z = 0.1; // ä¿æŒåœ¨ä¸Šå±‚ç›´åˆ°åŠ¨ç”»å®Œå…¨ç»“æŸ
                        cover.rotation.z = finalRotation * Math.PI / 180;
                        cover.scale.set(1, 1, 1); // ç«‹å³é‡ç½®ç¼©æ”¾ï¼Œä¸è¦ä»»ä½•æ”¾å¤§æ•ˆæœ
                    }
                };

                animate();
            }

            finishRollingAnimation(sourceCover, targetCover, newSourceCover, originalRow, originalCol, originalIndex, totalRotation) {
                // è·¯å¾„æ˜¯4çš„å€æ•°ï¼ŒtotalRotationåº”ä¸º360çš„å€æ•°ï¼›ç›´æ¥å½’é›¶
                // console.log(`æ»šåŠ¨å®Œæˆï¼Œæ€»æ—‹è½¬: ${totalRotation}åº¦ï¼Œå½’é›¶å¹¶å®Œæˆäº¤æ¢`);

                // ç«‹å³è®¾ç½®æœ€ç»ˆçŠ¶æ€
                sourceCover.rotation.z = 0;

                // å°†æºå°é¢ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆæ¥ç®¡ B ç‚¹ï¼‰
                sourceCover.position.set(targetCover.position.x, targetCover.position.y, 0);
                sourceCover.userData.row = targetCover.userData.row;
                sourceCover.userData.col = targetCover.userData.col;
                sourceCover.userData.index = targetCover.userData.index;

                // ç§»é™¤æ—§çš„ç›®æ ‡å°é¢
                this.scene.remove(targetCover);

                // å°† A ç‚¹çš„æ–°å°é¢æåˆ°æ­£å¸¸å±‚çº§
                newSourceCover.position.z = 0;
                newSourceCover.userData.isAnimating = false;
                newSourceCover.userData.isRolling = false;

                // æ›´æ–° covers æ•°ç»„æ˜ å°„ï¼š
                const targetIndexInArray = this.covers.indexOf(targetCover);
                const sourceIndexInArray = this.covers.indexOf(sourceCover);
                if (sourceIndexInArray !== -1) {
                    // ç”¨ A ç‚¹çš„æ–°å°é¢é¡¶æ›¿åŸæ¥çš„ sourceCover æ§½ä½
                    this.covers[sourceIndexInArray] = newSourceCover;
                }
                if (targetIndexInArray !== -1) {
                    // ç”¨ç§»åŠ¨è¿‡æ¥çš„ sourceCover é¡¶æ›¿ç›®æ ‡æ§½ä½
                    this.covers[targetIndexInArray] = sourceCover;
                }

                // é‡ç½®ç§»åŠ¨å°é¢çš„çŠ¶æ€
                sourceCover.userData.isRolling = false;
                sourceCover.userData.isAnimating = false;
                sourceCover.position.z = 0;
                sourceCover.scale.set(1, 1, 1);
                sourceCover.material.opacity = 1;

                // console.log(`å®Œæˆï¼šA ç‚¹å·²è¡¥ä¸Šæ–°å°é¢ (${originalRow},${originalCol})ï¼ŒB ç‚¹ç”±æºå°é¢æ¥ç®¡ (${sourceCover.userData.row},${sourceCover.userData.col})`);
            }

            playRollDropAnimation(cover) {
                // æ£€æŸ¥å°é¢æ˜¯å¦æ­£åœ¨è¿›è¡Œå…¶ä»–åŠ¨ç”»
                if (cover.userData.isAnimating) {
                    // console.log('å°é¢æ­£åœ¨åŠ¨ç”»ä¸­ï¼Œè·³è¿‡é€æ ¼ç¿»æ»šåŠ¨ç”»');
                    return;
                }

                // æ ‡è®°ä¸ºåŠ¨ç”»ä¸­
                cover.userData.isAnimating = true;

                // è·å–å½“å‰ä½ç½®ä¿¡æ¯
                const startRow = cover.userData.row;
                const startCol = cover.userData.col;

                // è®¡ç®—ç¿»æ»šè·¯å¾„ï¼ˆå‘ä¸‹ç¿»æ»šç›´åˆ°å‡ºçª—å£ï¼‰
                const rollPath = [];

                // ä»å½“å‰ä½ç½®å¼€å§‹ï¼Œä¸€ç›´ç¿»æ»šåˆ°çª—å£åº•éƒ¨ä¹‹å¤–
                for (let i = 1; i <= this.gridRows - startRow + 2; i++) { // +2ç¡®ä¿æ»šå‡ºçª—å£
                    rollPath.push({
                        row: startRow + i,
                        col: startCol,
                        index: (startRow + i) * this.gridCols + startCol
                    });
                }

                // console.log(`å¼€å§‹é€æ ¼ç¿»æ»š: ä»(${startRow},${startCol})ç¿»æ»š${rollPath.length}æ ¼ç›´åˆ°å‡ºçª—å£`);

                // åœ¨èµ·å§‹ä½ç½®åˆ›å»ºæ–°å°é¢
                const newAlbum = this.getRandomAlbum();
                const textureLoader = new THREE.TextureLoader();
                const newTexture = textureLoader.load(newAlbum, (loadedTexture) => {
                    this.adjustTextureForCover(loadedTexture);
                });

                const newGeometry = new THREE.PlaneGeometry(this.coverSize, this.coverSize);
                const newMaterial = new THREE.MeshBasicMaterial({
                    map: newTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                const newCover = new THREE.Mesh(newGeometry, newMaterial);
                newCover.position.set(cover.position.x, cover.position.y, -0.01);
                newCover.userData = {
                    row: startRow,
                    col: startCol,
                    index: startRow * this.gridCols + startCol,
                    albumPath: newAlbum,
                    originalPosition: { ...cover.userData.originalPosition },
                    originalRotation: { ...cover.userData.originalRotation }
                };
                this.scene.add(newCover);

                // æå‡ç¿»æ»šå°é¢çš„å±‚çº§
                cover.position.z = 0.2;

                // æ‰§è¡Œé€æ ¼ç¿»æ»šåŠ¨ç”»
                this.executeGridRolling(cover, rollPath, newCover, startRow, startCol);
            }

            executeGridRolling(cover, rollPath, newCover, startRow, startCol) {
                let currentStep = 0;
                const stepDuration = 350; // æ¯æ ¼ç¿»æ»šçš„æŒç»­æ—¶é—´

                // å½“å‰ä½ç½®
                let currentX = cover.position.x;
                let currentY = cover.position.y;

                const rollNextStep = () => {
                    if (currentStep >= rollPath.length) {
                        // ç¿»æ»šå®Œæˆï¼Œç§»é™¤ç¿»æ»šå°é¢
                        this.finishGridRolling(cover, newCover, startRow, startCol);
                        return;
                    }

                    const targetStep = rollPath[currentStep];

                    // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆå³ä½¿è¶…å‡ºç½‘æ ¼ä¹Ÿç»§ç»­è®¡ç®—ï¼‰
                    const targetX = this.startX + targetStep.col * (this.coverSize + this.gap) + this.coverSize / 2;
                    const targetY = this.startY - targetStep.row * (this.coverSize + this.gap) - this.coverSize / 2;

                    // æ‰§è¡Œå•æ ¼ç¿»æ»šåŠ¨ç”»
                    this.animateGridRollStep(cover, currentX, currentY, targetX, targetY, stepDuration, () => {
                        // æ›´æ–°å½“å‰ä½ç½®
                        currentX = targetX;
                        currentY = targetY;
                        currentStep++;

                        // çŸ­æš‚åœé¡¿åç»§ç»­ä¸‹ä¸€æ­¥
                        setTimeout(rollNextStep, 80);
                    });
                };

                // å¼€å§‹ç¿»æ»š
                rollNextStep();
            }

            animateGridRollStep(cover, startX, startY, targetX, targetY, duration, onComplete) {
                const startTime = Date.now();

                // è®¡ç®—ç¿»æ»šæ–¹å‘ï¼ˆè¿™é‡Œåªè€ƒè™‘å‘ä¸‹ç¿»æ»šï¼‰
                const isMovingDown = targetY < startY;

                if (!isMovingDown) {
                    // å¦‚æœä¸æ˜¯å‘ä¸‹ç§»åŠ¨ï¼Œç›´æ¥å®Œæˆ
                    onComplete();
                    return;
                }

                // ç¿»æ»šåŠ¨ç”»ï¼šæ²¿ç€Xè½´æ—‹è½¬ï¼ˆå‰åç¿»æ»šï¼‰
                const rollDistance = this.coverSize; // ç¿»æ»šè·ç¦»ç­‰äºå°é¢å¤§å°
                const startRotationX = cover.rotation.x; // ä»å½“å‰è§’åº¦å¼€å§‹ï¼Œä¿æŒç´¯è®¡æ—‹è½¬

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©ç¿»æ»šæ›´è‡ªç„¶
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                    // è®¡ç®—ç¿»æ»šä¸­å¿ƒç‚¹ï¼ˆä¸¤ä¸ªä½ç½®çš„ä¸­ç‚¹ï¼‰
                    const centerX = (startX + targetX) / 2;
                    const centerY = (startY + targetY) / 2;

                    // ç¿»æ»šè§’åº¦ï¼ˆæœ¬æ­¥ç´¯åŠ åˆ° 180Â°ï¼‰
                    const rollAngle = easeProgress * Math.PI;
                    const currentAngle = startRotationX + rollAngle;

                    // è®¡ç®—ç¿»æ»šè½¨è¿¹ä¸Šçš„ä½ç½®
                    // ä½¿ç”¨åœ†å¼§è½¨è¿¹æ¨¡æ‹Ÿç¿»æ»š
                    const radius = rollDistance / 2;
                    const arcX = centerX;
                    const arcY = centerY + radius * Math.cos(rollAngle);
                    const arcZ = 0.2 + radius * Math.sin(rollAngle); // Zè½´é«˜åº¦å˜åŒ–

                    // åº”ç”¨ä½ç½®
                    cover.position.x = arcX;
                    cover.position.y = arcY;
                    cover.position.z = Math.max(arcZ, 0.1); // ç¡®ä¿å§‹ç»ˆåœ¨å…¶ä»–å°é¢ä¹‹ä¸Š

                    // åº”ç”¨æ—‹è½¬ï¼ˆæ²¿Xè½´ç¿»æ»šï¼Œç´¯è®¡ï¼‰
                    cover.rotation.x = currentAngle;
                    cover.rotation.y = 0;
                    cover.rotation.z = 0;

                    // è½»å¾®çš„ç¼©æ”¾æ•ˆæœ
                    const scale = 1 + Math.sin(rollAngle) * 0.05;
                    cover.scale.set(scale, scale, scale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ç¡®ä¿æœ€ç»ˆçŠ¶æ€å‡†ç¡®ï¼ˆä¿æŒç´¯è®¡è§’åº¦ï¼Œä¸å½’é›¶ï¼‰
                        cover.position.x = targetX;
                        cover.position.y = targetY;
                        cover.position.z = 0.2;
                        cover.rotation.x = startRotationX + Math.PI;
                        cover.rotation.y = 0;
                        cover.rotation.z = 0;
                        cover.scale.set(1, 1, 1);

                        onComplete();
                    }
                };

                animate();
            }

            finishGridRolling(cover, newCover, startRow, startCol) {
                // console.log(`ç¿»æ»šå®Œæˆ: å°é¢å·²æ»šå‡ºçª—å£`);

                // ç§»é™¤ç¿»æ»šå°é¢ï¼ˆå·²ç»æ»šå‡ºçª—å£ï¼‰
                this.scene.remove(cover);

                // å°†æ–°å°é¢æåˆ°æ­£å¸¸å±‚çº§å¹¶æ›¿æ¢åŸæ¥çš„å°é¢
                newCover.position.z = 0;
                newCover.userData.isAnimating = false;

                // åœ¨coversæ•°ç»„ä¸­ç”¨æ–°å°é¢æ›¿æ¢åŸæ¥çš„å°é¢
                const originalIndex = this.covers.indexOf(cover);
                if (originalIndex !== -1) {
                    this.covers[originalIndex] = newCover;
                } else {
                    // å¦‚æœæ²¡æ‰¾åˆ°åŸå°é¢ï¼Œç›´æ¥æ·»åŠ æ–°å°é¢
                    this.covers.push(newCover);
                }

                // console.log(`èµ·å§‹ä½ç½®(${startRow},${startCol})å·²æ”¾ç½®æ–°å°é¢`);
            }
            
            playRowRollDropAnimation() {
                // é€‰æ‹©ä¸ŠåŠéƒ¨åˆ†çš„éšæœºè¡Œ
                const upperHalfRows = Math.floor(this.gridRows / 2);
                const selectedRow = Math.floor(Math.random() * upperHalfRows);
                
                // console.log(`æ‰§è¡Œè¡Œç¿»æ»šåŠ¨ç”»ï¼šé€‰æ‹©ç¬¬ ${selectedRow} è¡Œï¼ˆä»0å¼€å§‹ï¼‰`);
                
                // è·å–è¯¥è¡Œçš„æ‰€æœ‰å°é¢
                const rowCovers = this.covers.filter(cover => cover.userData.row === selectedRow);
                
                // æŒ‰åˆ—æ’åºï¼Œä»å·¦åˆ°å³
                rowCovers.sort((a, b) => a.userData.col - b.userData.col);
                
                // ä¾æ¬¡è§¦å‘æ¯ä¸ªå°é¢çš„rollDropåŠ¨ç”»ï¼Œé—´éš”200-400mséšæœº
                rowCovers.forEach((cover, index) => {
                    // ä¸ºæ¯ä¸ªå°é¢ç”Ÿæˆä¸€ä¸ª200-400ä¹‹é—´çš„éšæœºå»¶è¿Ÿ
                    const randomDelay = Math.floor(Math.random() * 201) + 200; // 200-400ä¹‹é—´çš„éšæœºæ•°
                    setTimeout(() => {
                        // æ£€æŸ¥å°é¢æ˜¯å¦å¯ä»¥è¿›è¡ŒåŠ¨ç”»
                        if (!cover.userData.isAnimating) {
                            this.playRollDropAnimation(cover);
                        }
                    }, index * randomDelay);
                });
            }
            
            playRowDropAnimation() {
                // é€‰æ‹©ä¸ŠåŠéƒ¨åˆ†çš„éšæœºè¡Œ
                const upperHalfRows = Math.floor(this.gridRows / 2);
                const selectedRow = Math.floor(Math.random() * upperHalfRows);
                
                // console.log(`æ‰§è¡Œè¡Œæ‰è½åŠ¨ç”»ï¼šé€‰æ‹©ç¬¬ ${selectedRow} è¡Œï¼ˆä»0å¼€å§‹ï¼‰`);
                
                // è·å–è¯¥è¡Œçš„æ‰€æœ‰å°é¢
                const rowCovers = this.covers.filter(cover => cover.userData.row === selectedRow);
                
                // æŒ‰åˆ—æ’åºï¼Œä»å·¦åˆ°å³
                rowCovers.sort((a, b) => a.userData.col - b.userData.col);
                
                // ä¾æ¬¡è§¦å‘æ¯ä¸ªå°é¢çš„dropåŠ¨ç”»ï¼Œé—´éš”200-400mséšæœº
                rowCovers.forEach((cover, index) => {
                    // ä¸ºæ¯ä¸ªå°é¢ç”Ÿæˆä¸€ä¸ª200-400ä¹‹é—´çš„éšæœºå»¶è¿Ÿ
                    const randomDelay = Math.floor(Math.random() * 201) + 200; // 200-400ä¹‹é—´çš„éšæœºæ•°
                    setTimeout(() => {
                        // æ£€æŸ¥å°é¢æ˜¯å¦å¯ä»¥è¿›è¡ŒåŠ¨ç”»
                        if (!cover.userData.isAnimating) {
                            this.playDropAnimation(cover);
                        }
                    }, index * randomDelay);
                });
            }

            playPinRotationAnimation(cover, chainLevel = 0) {
                // æ£€æŸ¥å°é¢æ˜¯å¦æ­£åœ¨è¿›è¡Œå…¶ä»–åŠ¨ç”»
                if (cover.userData.isAnimating) {
                    console.log('å°é¢æ­£åœ¨åŠ¨ç”»ä¸­ï¼Œè·³è¿‡å›¾é’‰æ—‹è½¬åŠ¨ç”»');
                    return;
                }

                // è·å–å½“å‰å°é¢çš„ä½ç½®
                const currentRow = cover.userData.row;
                const currentCol = cover.userData.col;

                // å¯»æ‰¾åˆé€‚çš„2x2åŒºåŸŸå’Œæ—‹è½¬æ–¹å‘
                const targetPositions = this.findPinRotationTarget(currentRow, currentCol);

                if (!targetPositions) {
                    console.log('æœªæ‰¾åˆ°åˆé€‚çš„2x2åŒºåŸŸè¿›è¡Œå›¾é’‰æ—‹è½¬ï¼Œæ‰§è¡Œæ™®é€šç¿»è½¬åŠ¨ç”»');
                    this.playFlipAnimation(cover);
                    return;
                }

                // è·å–å½“å‰ä½ç½®å’Œç›®æ ‡ä½ç½®
                const current = targetPositions.current;
                const target = targetPositions.target;
                const currentPos = targetPositions[current];
                const targetPos = targetPositions[target];

                // å¦‚æœæ˜¯è”åŠ¨åŠ¨ç”»ï¼Œæ·»åŠ è”åŠ¨æ ‡è®°
                const chainText = chainLevel > 0 ? `[è”åŠ¨${chainLevel}] ` : '';
                // console.log(`${chainText}å¼€å§‹å›¾é’‰æ—‹è½¬åŠ¨ç”»: ä»ä½ç½®${current.substring(3)}(${currentRow},${currentCol})æ—‹è½¬åˆ°ä½ç½®${target.substring(3)}(${targetPos.row},${targetPos.col})`);

                // æ‰§è¡Œå›¾é’‰æ—‹è½¬åŠ¨ç”»ï¼Œä¼ é€’chainLevelå‚æ•°
                this.executePinRotation(cover, targetPositions, null, chainLevel);
            }

            findPinRotationTarget(currentRow, currentCol) {
                // åªæ”¯æŒå¯¹è§’çº¿è½¬æ¢åŠ¨ç”»
                // 2x2ç½‘æ ¼å¸ƒå±€ï¼š
                // 1 2
                // 3 4

                // åªä¿ç•™4ç§å¯¹è§’çº¿æ—‹è½¬é…ç½®
                const configurations = [
                    // 1. å½“å‰ä½ç½®ä¸º1ï¼ˆå·¦ä¸Šè§’ï¼‰ï¼Œæ—‹è½¬åˆ°4ï¼ˆå³ä¸‹è§’ï¼‰
                    {
                        current: 'pos1',
                        target: 'pos4',
                        positions: {
                            pos1: { row: currentRow, col: currentCol },       // å·¦ä¸Šè§’ï¼ˆå½“å‰ä½ç½®ï¼‰
                            pos2: { row: currentRow, col: currentCol + 1 },   // å³ä¸Šè§’
                            pos3: { row: currentRow + 1, col: currentCol },   // å·¦ä¸‹è§’
                            pos4: { row: currentRow + 1, col: currentCol + 1 } // å³ä¸‹è§’ï¼ˆç›®æ ‡ä½ç½®ï¼‰
                        }
                    },
                    // 2. å½“å‰ä½ç½®ä¸º2ï¼ˆå³ä¸Šè§’ï¼‰ï¼Œæ—‹è½¬åˆ°3ï¼ˆå·¦ä¸‹è§’ï¼‰
                    {
                        current: 'pos2',
                        target: 'pos3',
                        positions: {
                            pos1: { row: currentRow, col: currentCol - 1 },   // å·¦ä¸Šè§’
                            pos2: { row: currentRow, col: currentCol },       // å³ä¸Šè§’ï¼ˆå½“å‰ä½ç½®ï¼‰
                            pos3: { row: currentRow + 1, col: currentCol - 1 }, // å·¦ä¸‹è§’ï¼ˆç›®æ ‡ä½ç½®ï¼‰
                            pos4: { row: currentRow + 1, col: currentCol }    // å³ä¸‹è§’
                        }
                    },
                    // 3. å½“å‰ä½ç½®ä¸º3ï¼ˆå·¦ä¸‹è§’ï¼‰ï¼Œæ—‹è½¬åˆ°2ï¼ˆå³ä¸Šè§’ï¼‰
                    {
                        current: 'pos3',
                        target: 'pos2',
                        positions: {
                            pos1: { row: currentRow - 1, col: currentCol },   // å·¦ä¸Šè§’
                            pos2: { row: currentRow - 1, col: currentCol + 1 }, // å³ä¸Šè§’ï¼ˆç›®æ ‡ä½ç½®ï¼‰
                            pos3: { row: currentRow, col: currentCol },       // å·¦ä¸‹è§’ï¼ˆå½“å‰ä½ç½®ï¼‰
                            pos4: { row: currentRow, col: currentCol + 1 }    // å³ä¸‹è§’
                        }
                    },
                    // 4. å½“å‰ä½ç½®ä¸º4ï¼ˆå³ä¸‹è§’ï¼‰ï¼Œæ—‹è½¬åˆ°1ï¼ˆå·¦ä¸Šè§’ï¼‰
                    {
                        current: 'pos4',
                        target: 'pos1',
                        positions: {
                            pos1: { row: currentRow - 1, col: currentCol - 1 }, // å·¦ä¸Šè§’ï¼ˆç›®æ ‡ä½ç½®ï¼‰
                            pos2: { row: currentRow - 1, col: currentCol },   // å³ä¸Šè§’
                            pos3: { row: currentRow, col: currentCol - 1 },   // å·¦ä¸‹è§’
                            pos4: { row: currentRow, col: currentCol }        // å³ä¸‹è§’ï¼ˆå½“å‰ä½ç½®ï¼‰
                        }
                    }
                ];

                // éšæœºé€‰æ‹©ä¸€ä¸ªé…ç½®
                const shuffledConfigs = [...configurations].sort(() => Math.random() - 0.5);
                
                // å°è¯•æ¯ä¸€ç§é…ç½®ï¼Œç›´åˆ°æ‰¾åˆ°æœ‰æ•ˆçš„
                for (const config of shuffledConfigs) {
                    const { positions, current, target } = config;
                    
                    // æ£€æŸ¥æ‰€æœ‰ä½ç½®æ˜¯å¦åœ¨ç½‘æ ¼èŒƒå›´å†…
                    let validPositions = true;
                    for (const pos of Object.values(positions)) {
                        if (pos.row < 0 || pos.row >= this.gridRows ||
                            pos.col < 0 || pos.col >= this.gridCols) {
                            validPositions = false;
                            break;
                        }
                    }
                    
                    if (!validPositions) continue;
                    
                    // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åŒ¹é…
                    if (positions[current].row !== currentRow || positions[current].col !== currentCol) {
                        continue;
                    }
                    
                    // æŸ¥æ‰¾å¯¹åº”çš„å°é¢å¯¹è±¡
                    const covers = {
                        pos1: this.findCoverAtPosition(positions.pos1.row, positions.pos1.col),
                        pos2: this.findCoverAtPosition(positions.pos2.row, positions.pos2.col),
                        pos3: this.findCoverAtPosition(positions.pos3.row, positions.pos3.col),
                        pos4: this.findCoverAtPosition(positions.pos4.row, positions.pos4.col)
                    };
                    
                    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä½ç½®éƒ½æœ‰å°é¢ä¸”æ²¡æœ‰åœ¨åŠ¨ç”»ä¸­
                    let validCovers = true;
                    for (const [key, coverObj] of Object.entries(covers)) {
                        if (!coverObj || coverObj.userData.isAnimating) {
                            validCovers = false;
                            break;
                        }
                    }
                    
                    if (!validCovers) continue;
                    
                    // è¿”å›æœ‰æ•ˆçš„é…ç½®
                    return {
                        pos1: positions.pos1,
                        pos2: positions.pos2,
                        pos3: positions.pos3,
                        pos4: positions.pos4,
                        covers,
                        current,
                        target
                    };
                }
                
                return null; // æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆé…ç½®
            }

            findCoverAtPosition(row, col) {
                return this.covers.find(cover =>
                    cover.userData.row === row && cover.userData.col === col
                );
            }

            executePinRotation(rotatingCover, targetPositions, newCover = null, chainLevel = 0) {
                // è·å–å½“å‰ä½ç½®å’Œç›®æ ‡ä½ç½®
                const current = targetPositions.current;
                const target = targetPositions.target;
                
                // æ ‡è®°ç›¸å…³å°é¢ä¸ºåŠ¨ç”»ä¸­
                rotatingCover.userData.isAnimating = true;
                targetPositions.covers[target].userData.isAnimating = true;

                // è®¾ç½®å±‚çº§å…³ç³»ï¼Œè§†è§‰ä¸Šå¹³æ•´ï¼Œé€»è¾‘ä¸Šåˆ†å±‚
                // ç¡®å®šæ—‹è½¬è·¯å¾„ä¸Šçš„å°é¢ï¼Œä½¿å…¶ç¨é«˜ä¸€äº›ï¼Œä¾¿äºè§†è§‰æ•ˆæœ
                // ç¡®å®šä¸­é—´ä½ç½®çš„å°é¢ï¼Œä½¿å…¶ç¨é«˜ï¼Œä¾¿äºåœ¨ä¸‹æ–¹æ›´æ¢å°é¢
                const middlePositions = this.determineMiddlePositions(current, target);
                
                // è®¾ç½®ä¸­é—´ä½ç½®å°é¢çš„Zè½´å±‚çº§ç¨é«˜
                for (const posKey of middlePositions) {
                    if (targetPositions.covers[posKey]) {
                        targetPositions.covers[posKey].position.z = 0.002; // ä¸­é—´ä½ç½®ç¨é«˜
                        // console.log(`è®¾ç½®ä½ç½®${posKey.substring(3)}çš„Zè½´å±‚çº§ä¸º0.002`);
                    }
                }

                // è®¡ç®—å›¾é’‰ä½ç½®ï¼ˆå››ä¸ªå°é¢çš„äº¤æ±‡ä¸­å¿ƒç‚¹ï¼‰
                // æ‰¾åˆ°2x2åŒºåŸŸçš„å·¦ä¸Šè§’ä½ç½®
                const cornerRow = Math.min(targetPositions.pos1.row, targetPositions.pos2.row, 
                                         targetPositions.pos3.row, targetPositions.pos4.row);
                const cornerCol = Math.min(targetPositions.pos1.col, targetPositions.pos2.col, 
                                         targetPositions.pos3.col, targetPositions.pos4.col);
                
                // å›¾é’‰ä½ç½®æ˜¯2x2åŒºåŸŸçš„ä¸­å¿ƒç‚¹
                const pinX = this.startX + (cornerCol + 0.5) * (this.coverSize + this.gap) + this.coverSize / 2;
                const pinY = this.startY - (cornerRow + 0.5) * (this.coverSize + this.gap) - this.coverSize / 2;

                // è®¡ç®—æ—‹è½¬å°é¢çš„ä¸­å¿ƒç‚¹åæ ‡
                const currentPosX = this.startX + targetPositions[current].col * (this.coverSize + this.gap) + this.coverSize / 2;
                const currentPosY = this.startY - targetPositions[current].row * (this.coverSize + this.gap) - this.coverSize / 2;
                
                // è®¡ç®—ç›®æ ‡ä½ç½®çš„ä¸­å¿ƒç‚¹åæ ‡
                const targetPosX = this.startX + targetPositions[target].col * (this.coverSize + this.gap) + this.coverSize / 2;
                const targetPosY = this.startY - targetPositions[target].row * (this.coverSize + this.gap) - this.coverSize / 2;

                // è®¡ç®—æ—‹è½¬åŠå¾„ï¼ˆä»å½“å‰ä½ç½®ä¸­å¿ƒåˆ°å›¾é’‰çš„è·ç¦»ï¼‰
                const radius = Math.sqrt(Math.pow(currentPosX - pinX, 2) + Math.pow(currentPosY - pinY, 2));

                // è®¡ç®—èµ·å§‹è§’åº¦å’Œç›®æ ‡è§’åº¦
                const startAngle = Math.atan2(currentPosY - pinY, currentPosX - pinX);
                
                // è®¡ç®—ç›®æ ‡è§’åº¦ï¼ˆåŸºäºç›®æ ‡ä½ç½®ï¼‰
                const endAngle = Math.atan2(targetPosY - pinY, targetPosX - pinX);
                
                // ç¡®å®šæ—‹è½¬æ–¹å‘ï¼ˆé¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆï¼Œé€‰æ‹©è¾ƒçŸ­çš„è·¯å¾„ï¼‰
                let targetAngle = endAngle;
                const angleDiff1 = (endAngle - startAngle + 2 * Math.PI) % (2 * Math.PI); // é¡ºæ—¶é’ˆ
                const angleDiff2 = (startAngle - endAngle + 2 * Math.PI) % (2 * Math.PI); // é€†æ—¶é’ˆ
                
                // é€‰æ‹©è¾ƒçŸ­çš„æ—‹è½¬è·¯å¾„
                if (angleDiff1 <= angleDiff2) {
                    // é¡ºæ—¶é’ˆæ—‹è½¬
                    targetAngle = startAngle + angleDiff1;
                } else {
                    // é€†æ—¶é’ˆæ—‹è½¬
                    targetAngle = startAngle - angleDiff2;
                }

                // åœ¨å½“å‰ä½ç½®åæ–¹ç«‹å³åˆ›å»ºæ–°å°é¢
                let createdNewCover = newCover;
                if (!createdNewCover) {
                    const newAlbum = this.getRandomAlbum();
                    const textureLoader = new THREE.TextureLoader();
                    const newTexture = textureLoader.load(newAlbum, (loadedTexture) => {
                        this.adjustTextureForCover(loadedTexture);
                    });

                    const newGeometry = new THREE.PlaneGeometry(this.coverSize, this.coverSize);
                    const newMaterial = new THREE.MeshBasicMaterial({
                        map: newTexture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });

                    createdNewCover = new THREE.Mesh(newGeometry, newMaterial);
                    createdNewCover.position.set(currentPosX, currentPosY, -0.01); // æ–°å°é¢åœ¨åæ–¹
                    createdNewCover.userData = {
                        row: targetPositions[current].row,
                        col: targetPositions[current].col,
                        index: targetPositions[current].row * this.gridCols + targetPositions[current].col,
                        albumPath: newAlbum,
                        originalPosition: { x: currentPosX, y: currentPosY, z: 0 },
                        originalRotation: { x: 0, y: 0, z: 0 }
                    };
                    this.scene.add(createdNewCover);
                }

                // æ‰§è¡Œæ—‹è½¬åŠ¨ç”»ï¼Œä¼ é€’chainLevelå‚æ•°
                this.animatePinRotation(rotatingCover, targetPositions, pinX, pinY, radius, startAngle, targetAngle, createdNewCover, middlePositions, chainLevel);
            }
            
            // ç¡®å®šä¸­é—´ä½ç½®çš„å°é¢ï¼Œç”¨äºè®¾ç½®Zè½´å±‚çº§
            determineMiddlePositions(current, target) {
                // æ ¹æ®å¯¹è§’çº¿æ—‹è½¬æ–¹å‘ç¡®å®šä¸­é—´ä½ç½®
                const middlePositions = [];
                
                // å¯¹è§’çº¿æ—‹è½¬
                if ((current === 'pos1' && target === 'pos4') || (current === 'pos4' && target === 'pos1')) {
                    // 1->4æˆ–4->1ï¼Œä¸­é—´ä½ç½®æ˜¯2å’Œ3
                    middlePositions.push('pos2', 'pos3');
                } else if ((current === 'pos2' && target === 'pos3') || (current === 'pos3' && target === 'pos2')) {
                    // 2->3æˆ–3->2ï¼Œä¸­é—´ä½ç½®æ˜¯1å’Œ4
                    middlePositions.push('pos1', 'pos4');
                }
                
                return middlePositions;
            }

            animatePinRotation(rotatingCover, targetPositions, pinX, pinY, radius, startAngle, targetAngle, newCover, middlePositions, chainLevel = 0) {
                const duration = 800; // åŠ¨ç”»æŒç»­æ—¶é—´800ms
                const startTime = Date.now();

                // ä¿å­˜åŸå§‹Zè½´ä½ç½®
                const originalZ = rotatingCover.position.z;

                // åˆ›å»ºä¸­é—´æ›¿æ¢å°é¢ï¼ˆå½“æ—‹è½¬å°é¢è¢«å…¶ä»–å°é¢è¦†ç›–æ—¶ä½¿ç”¨ï¼‰
                let midReplacementCover = null;
                let hasCreatedMidReplacement = false;
                let angleOffset = 0; // è§’åº¦åç§»é‡ï¼Œç”¨äºä¿®æ­£æ¢å°é¢åçš„è§’åº¦

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // çº¿æ€§åŒ€é€ŸåŠ¨ç”»
                    const easedProgress = progress;

                    // è®¡ç®—å½“å‰è§’åº¦
                    const currentAngle = startAngle + (targetAngle - startAngle) * easedProgress;

                    // è®¡ç®—å½“å‰ä½ç½®ï¼ˆå°é¢ä¸­å¿ƒç‚¹çš„ä½ç½®ï¼‰
                    const currentX = pinX + radius * Math.cos(currentAngle);
                    const currentY = pinY + radius * Math.sin(currentAngle);

                    // è®¡ç®—å°é¢çš„æ—‹è½¬è§’åº¦ï¼Œæ¨¡æ‹Ÿä»¥å›¾é’‰ä¸ºæ”¯ç‚¹çš„æ—‹è½¬
                    const rotationAngle = currentAngle - startAngle;

                    // åŠ¨æ€è°ƒæ•´Zè½´å±‚çº§ï¼Œå®ç°å°é¢åœ¨ä¸‹æ–¹æ›´æ¢çš„æ•ˆæœ
                    // æ—‹è½¬åˆå§‹å’Œç»“æŸé˜¶æ®µï¼Œå°é¢åœ¨ä¸Šå±‚ï¼›ä¸­é—´é˜¶æ®µï¼Œå°é¢åœ¨ä¸‹å±‚
                    let zPosition;
                    if (progress < 0.3 || progress > 0.7) {
                        // åˆå§‹å’Œç»“æŸé˜¶æ®µï¼Œå°é¢åœ¨ä¸Šå±‚
                        zPosition = 0.001;
                    } else {
                        // ä¸­é—´é˜¶æ®µï¼Œå°é¢åœ¨ä¸‹å±‚ï¼Œä½äºä¸­é—´ä½ç½®çš„å°é¢
                        zPosition = -0.001;
                    }

                    // è®¡ç®—è¿›åº¦ï¼Œä¸­é—´æ¢å°é¢
                    const rotationProgress = Math.abs(currentAngle - startAngle) / Math.abs(targetAngle - startAngle);

                    // ä¸­é—´æ¢å°é¢ï¼Œå½“å°é¢åœ¨ä¸‹æ–¹æ—¶è¿›è¡Œæ›´æ¢
                    if (!hasCreatedMidReplacement && rotationProgress > 0.4 && rotationProgress < 0.6) {
                        angleOffset = this.createMidReplacementCover(rotatingCover, targetPositions);
                        hasCreatedMidReplacement = true;
                        console.log('åœ¨ä¸­é—´ä½ç½®ä¸‹æ–¹æ›´æ¢å°é¢');
                    }

                    // åº”ç”¨å˜æ¢
                    rotatingCover.position.set(currentX, currentY, zPosition);
                    rotatingCover.rotation.z = rotationAngle + angleOffset; // åŠ ä¸Šè§’åº¦åç§»é‡

                    // è½»å¾®çš„ç¼©æ”¾æ•ˆæœå¢å¼ºè§†è§‰å†²å‡»
                    const scale = 1 + Math.sin(easedProgress * Math.PI * 2) * 0.03;
                    rotatingCover.scale.set(scale, scale, scale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // åŠ¨ç”»å®Œæˆï¼Œè¿›è¡Œæœ€ç»ˆå¤„ç†ï¼Œä¼ é€’chainLevelå‚æ•°
                        this.finishPinRotation(rotatingCover, targetPositions, newCover, chainLevel);
                    }
                };

                animate();
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            easeInQuad(t) {
                // äºŒæ¬¡æ–¹ç¼“åŠ¨ï¼šæ¨¡æ‹Ÿé‡åŠ›åŠ é€Ÿåº¦ï¼Œæ…¢å¯åŠ¨ç„¶ååŠ é€Ÿ
                return t * t;
            }

            createMidReplacementCover(rotatingCover, targetPositions) {
                // è·å–å½“å‰ä½ç½®å’Œç›®æ ‡ä½ç½®
                const current = targetPositions.current;
                const target = targetPositions.target;
                
                // å½“æ—‹è½¬å°é¢ç»è¿‡ä¸­é—´ä½ç½®æ—¶ï¼Œåœ¨ä¸‹æ–¹æ›´æ¢å°é¢
                // console.log(`åœ¨å¯¹è§’çº¿æ—‹è½¬è¿‡ç¨‹ä¸­çš„ä¸­é—´ä½ç½®ä¸‹æ–¹æ›´æ¢å°é¢ï¼Œä»${current}åˆ°${target}`);

                // ç¡®ä¿æ—‹è½¬å°é¢å¤„äºè¾ƒä½çš„Zè½´å±‚çº§ï¼Œä½¿å…¶åœ¨å…¶ä»–å°é¢ä¸‹æ–¹
                rotatingCover.position.z = -0.001;
                
                const newAlbum = this.getRandomAlbum();
                const textureLoader = new THREE.TextureLoader();
                const newTexture = textureLoader.load(newAlbum, (loadedTexture) => {
                    this.adjustTextureForCover(loadedTexture);

                    // åŠ è½½å®Œæˆåç«‹å³æ›´æ¢æ—‹è½¬å°é¢çš„æè´¨
                    rotatingCover.material.map = newTexture;
                    rotatingCover.material.needsUpdate = true;
                    rotatingCover.userData.albumPath = newAlbum;

                    console.log('æ—‹è½¬å°é¢å·²åœ¨ä¸­é—´ä½ç½®ä¸‹æ–¹æ›´æ¢ä¸ºæ–°ä¸“è¾‘');
                });

                // å¯¹è§’çº¿æ—‹è½¬ï¼ˆ1->4æˆ–4->1ï¼Œ2->3æˆ–3->2ï¼‰éœ€è¦180åº¦åç§»
                const angleOffset = -Math.PI; // 180åº¦åç§»
                
                return angleOffset;
            }

            finishPinRotation(rotatingCover, targetPositions, newCover, chainLevel = 0) {
                // è·å–å½“å‰ä½ç½®å’Œç›®æ ‡ä½ç½®
                const current = targetPositions.current;
                const target = targetPositions.target;
                
                // console.log(`å›¾é’‰æ—‹è½¬åŠ¨ç”»å®Œæˆï¼Œä»ä½ç½®${current.substring(3)}æ—‹è½¬åˆ°ä½ç½®${target.substring(3)}`);

                // è®¡ç®—ç›®æ ‡ä½ç½®çš„ç²¾ç¡®åæ ‡
                const targetPosX = this.startX + targetPositions[target].col * (this.coverSize + this.gap) + this.coverSize / 2;
                const targetPosY = this.startY - targetPositions[target].row * (this.coverSize + this.gap) - this.coverSize / 2;

                // å°†æ—‹è½¬å°é¢ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼Œæ¢å¤æ­£å¸¸Zè½´å±‚çº§
                rotatingCover.position.set(targetPosX, targetPosY, 0);
                rotatingCover.scale.set(1, 1, 1); // é‡ç½®ç¼©æ”¾

                // æ›´æ–°æ—‹è½¬å°é¢çš„ç”¨æˆ·æ•°æ®
                rotatingCover.userData.row = targetPositions[target].row;
                rotatingCover.userData.col = targetPositions[target].col;
                rotatingCover.userData.index = targetPositions[target].row * this.gridCols + targetPositions[target].col;
                rotatingCover.userData.originalPosition = { x: targetPosX, y: targetPosY, z: 0 };

                // ç§»é™¤åŸç›®æ ‡ä½ç½®çš„å°é¢
                this.scene.remove(targetPositions.covers[target]);

                // å°†æ–°å°é¢æåˆ°æ­£å¸¸å±‚çº§
                newCover.position.z = 0;

                // æ›´æ–°coversæ•°ç»„
                const currentCoverIndex = this.covers.indexOf(targetPositions.covers[current]);
                const targetCoverIndex = this.covers.indexOf(targetPositions.covers[target]);

                // ç”¨æ–°å°é¢æ›¿æ¢å½“å‰ä½ç½®çš„åŸå°é¢
                if (currentCoverIndex !== -1) {
                    this.covers[currentCoverIndex] = newCover;
                }

                // ç”¨æ—‹è½¬å°é¢æ›¿æ¢ç›®æ ‡ä½ç½®çš„åŸå°é¢
                if (targetCoverIndex !== -1) {
                    this.covers[targetCoverIndex] = rotatingCover;
                }

                // é‡ç½®æ‰€æœ‰å°é¢çš„zä½ç½®åˆ°æ­£å¸¸å±‚çº§
                for (const posKey of ['pos1', 'pos2', 'pos3', 'pos4']) {
                    if (targetPositions.covers[posKey] && posKey !== current && posKey !== target) {
                        targetPositions.covers[posKey].position.z = 0;
                        // console.log(`é‡ç½®ä½ç½®${posKey.substring(3)}çš„Zè½´å±‚çº§ä¸º0`);
                    }
                }

                // é‡ç½®åŠ¨ç”»çŠ¶æ€
                rotatingCover.userData.isAnimating = false;
                newCover.userData.isAnimating = false;

                // console.log(`å›¾é’‰æ—‹è½¬å®Œæˆ: å°é¢ä»ä½ç½®${current.substring(3)}æ—‹è½¬åˆ°ä½ç½®${target.substring(3)}ï¼Œä½ç½®${current.substring(3)}å·²æ”¾ç½®æ–°å°é¢ï¼ŒåŸä½ç½®${target.substring(3)}çš„å°é¢å·²è¢«ç§»é™¤`);
                
                // æ·»åŠ è”åŠ¨åŠ¨ç”»é€»è¾‘
                // é™åˆ¶è”åŠ¨å±‚çº§ï¼Œé¿å…æ— é™è”åŠ¨
                const maxChainLevel = 5; // æœ€å¤§è”åŠ¨æ¬¡æ•°
                if (chainLevel < maxChainLevel) {
                    // å‡ ä¹æ— å»¶è¿Ÿåœ°æ£€æŸ¥è”åŠ¨æ¡ä»¶ï¼Œä½¿åŠ¨ç”»æ›´åŠ æµç•…
                    setTimeout(() => {
                        this.checkAndTriggerChainedAnimations(rotatingCover, targetPositions, chainLevel);
                    }, 1); // 1mså»¶è¿Ÿï¼Œå‡ ä¹æ— é—´éš”
                }
            }
            
            // æ£€æŸ¥å¹¶è§¦å‘è”åŠ¨åŠ¨ç”»
            checkAndTriggerChainedAnimations(rotatingCover, lastTargetPositions, chainLevel) {
                // è·å–ä¸Šä¸€æ¬¡åŠ¨ç”»çš„ç›®æ ‡ä½ç½®
                const lastTarget = lastTargetPositions.target;
                const targetRow = rotatingCover.userData.row;
                const targetCol = rotatingCover.userData.col;
                
                // éšæœºå†³å®šæ˜¯å¦è§¦å‘è”åŠ¨ï¼ˆå¢åŠ éšæœºæ€§ï¼‰
                const shouldTriggerChain = Math.random() < 0.8; // 80%çš„æ¦‚ç‡è§¦å‘è”åŠ¨
                
                if (!shouldTriggerChain) {
                    console.log('éšæœºå†³å®šä¸è§¦å‘è”åŠ¨åŠ¨ç”»');
                    return;
                }
                
                // éšæœºé€‰æ‹©è”åŠ¨ç±»å‹
                const chainTypes = this.determineAvailableChainTypes(rotatingCover, lastTarget, chainLevel);
                
                if (chainTypes.length === 0) {
                    console.log('æ²¡æœ‰å¯ç”¨çš„è”åŠ¨åŠ¨ç”»ç±»å‹');
                    return;
                }
                
                // éšæœºé€‰æ‹©ä¸€ç§è”åŠ¨ç±»å‹
                const randomChainType = chainTypes[Math.floor(Math.random() * chainTypes.length)];
                // console.log(`é€‰æ‹©è”åŠ¨ç±»å‹: ${randomChainType}`);
                
                // æ ¹æ®è”åŠ¨ç±»å‹è§¦å‘ç›¸åº”çš„åŠ¨ç”»
                switch (randomChainType) {
                    case 'sequential':
                        this.triggerSequentialChain(rotatingCover, lastTarget, chainLevel);
                        break;
                    case 'downward':
                        this.triggerDownwardChain(rotatingCover, lastTarget, chainLevel);
                        break;
                    case 'fallAnimation':
                        this.triggerFallAnimation(rotatingCover, lastTarget, chainLevel);
                        break;
                }
            }
            
            // ç¡®å®šå¯ç”¨çš„è”åŠ¨ç±»å‹
            determineAvailableChainTypes(rotatingCover, lastTarget, chainLevel) {
                const availableTypes = [];
                const targetRow = rotatingCover.userData.row;
                const targetCol = rotatingCover.userData.col;
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œé¡ºåŠ¿è”åŠ¨ï¼ˆåŒä¸€2x2åŒºåŸŸå†…çš„å¯¹è§’æ—‹è½¬ï¼‰
                if (this.canTriggerSequentialChain(rotatingCover, lastTarget)) {
                    availableTypes.push('sequential');
                }
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œå‘ä¸‹è”åŠ¨ï¼ˆå½“å‰ä½ç½®ä¸‹æ–¹çš„å°é¢æ—‹è½¬ï¼‰
                if (this.canTriggerDownwardChain(rotatingCover)) {
                    availableTypes.push('downward');
                }
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è§¦å‘é£˜è½åŠ¨ç”»
                if (this.canTriggerFallAnimation(rotatingCover, lastTarget)) {
                    availableTypes.push('fallAnimation');
                }
                
                return availableTypes;
            }
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œé¡ºåŠ¿è”åŠ¨
            canTriggerSequentialChain(rotatingCover, lastTarget) {
                // è·å–æ—‹è½¬å°é¢å½“å‰ä½ç½®
                const row = rotatingCover.userData.row;
                const col = rotatingCover.userData.col;
                
                // æ ¹æ®lastTargetå’Œå½“å‰ä½ç½®ï¼Œç¡®å®šå¯èƒ½çš„é¡ºåŠ¿è”åŠ¨å°é¢
                let potentialCoverRow, potentialCoverCol;
                
                // æ ¹æ®ä¸Šä¸€æ¬¡æ—‹è½¬çš„ç›®æ ‡ä½ç½®ç¡®å®šæ½œåœ¨çš„é¡ºåŠ¿è”åŠ¨å°é¢ä½ç½®
                if (lastTarget === 'pos4') { // å¦‚æœæ—‹è½¬åˆ°äº†å³ä¸‹è§’
                    potentialCoverRow = row;
                    potentialCoverCol = col - 1; // å·¦ä¾§å°é¢
                } else if (lastTarget === 'pos3') { // å¦‚æœæ—‹è½¬åˆ°äº†å·¦ä¸‹è§’
                    potentialCoverRow = row;
                    potentialCoverCol = col + 1; // å³ä¾§å°é¢
                } else if (lastTarget === 'pos2') { // å¦‚æœæ—‹è½¬åˆ°äº†å³ä¸Šè§’
                    potentialCoverRow = row + 1;
                    potentialCoverCol = col; // ä¸‹æ–¹å°é¢
                } else if (lastTarget === 'pos1') { // å¦‚æœæ—‹è½¬åˆ°äº†å·¦ä¸Šè§’
                    potentialCoverRow = row + 1;
                    potentialCoverCol = col; // ä¸‹æ–¹å°é¢
                }
                
                // æ£€æŸ¥æ½œåœ¨å°é¢æ˜¯å¦å­˜åœ¨ä¸”æœªåœ¨åŠ¨ç”»ä¸­
                const potentialCover = this.findCoverAtPosition(potentialCoverRow, potentialCoverCol);
                return potentialCover && !potentialCover.userData.isAnimating;
            }
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œå‘ä¸‹è”åŠ¨
            canTriggerDownwardChain(rotatingCover) {
                // è·å–æ—‹è½¬å°é¢å½“å‰ä½ç½®
                const row = rotatingCover.userData.row;
                const col = rotatingCover.userData.col;
                
                // æ£€æŸ¥ä¸‹æ–¹å°é¢æ˜¯å¦å­˜åœ¨ä¸”æœªåœ¨åŠ¨ç”»ä¸­
                const downCover = this.findCoverAtPosition(row + 1, col);
                return downCover && !downCover.userData.isAnimating;
            }
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥è§¦å‘é£˜è½åŠ¨ç”»
            canTriggerFallAnimation(rotatingCover, lastTarget) {
                // è·å–æ—‹è½¬å°é¢å½“å‰ä½ç½®
                const row = rotatingCover.userData.row;
                const col = rotatingCover.userData.col;
                
                // æ ¹æ®lastTargetå’Œå½“å‰ä½ç½®ï¼Œç¡®å®šå¯èƒ½è§¦å‘é£˜è½åŠ¨ç”»çš„å°é¢
                let potentialCoverRow, potentialCoverCol;
                
                // æ ¹æ®ä¸Šä¸€æ¬¡æ—‹è½¬çš„ç›®æ ‡ä½ç½®ç¡®å®šæ½œåœ¨çš„é£˜è½å°é¢ä½ç½®
                if (lastTarget === 'pos4' || lastTarget === 'pos3') { // å¦‚æœæ—‹è½¬åˆ°äº†ä¸‹æ–¹
                    potentialCoverRow = row - 1;
                    potentialCoverCol = col; // ä¸Šæ–¹å°é¢
                } else if (lastTarget === 'pos2' || lastTarget === 'pos1') { // å¦‚æœæ—‹è½¬åˆ°äº†ä¸Šæ–¹
                    potentialCoverRow = row;
                    potentialCoverCol = col + (lastTarget === 'pos2' ? -1 : 1); // å·¦ä¾§æˆ–å³ä¾§å°é¢
                }
                
                // æ£€æŸ¥æ½œåœ¨å°é¢æ˜¯å¦å­˜åœ¨ä¸”æœªåœ¨åŠ¨ç”»ä¸­
                const potentialCover = this.findCoverAtPosition(potentialCoverRow, potentialCoverCol);
                return potentialCover && !potentialCover.userData.isAnimating;
            }
            
            // è§¦å‘é¡ºåŠ¿è”åŠ¨
            triggerSequentialChain(rotatingCover, lastTarget, chainLevel) {
                // è·å–æ—‹è½¬å°é¢å½“å‰ä½ç½®
                const row = rotatingCover.userData.row;
                const col = rotatingCover.userData.col;
                
                // æ ¹æ®lastTargetå’Œå½“å‰ä½ç½®ï¼Œç¡®å®šé¡ºåŠ¿è”åŠ¨å°é¢
                let chainCoverRow, chainCoverCol;
                
                // æ ¹æ®ä¸Šä¸€æ¬¡æ—‹è½¬çš„ç›®æ ‡ä½ç½®ç¡®å®šè”åŠ¨å°é¢ä½ç½®
                if (lastTarget === 'pos4') { // å¦‚æœæ—‹è½¬åˆ°äº†å³ä¸‹è§’
                    chainCoverRow = row;
                    chainCoverCol = col - 1; // å·¦ä¾§å°é¢
                } else if (lastTarget === 'pos3') { // å¦‚æœæ—‹è½¬åˆ°äº†å·¦ä¸‹è§’
                    chainCoverRow = row;
                    chainCoverCol = col + 1; // å³ä¾§å°é¢
                } else if (lastTarget === 'pos2') { // å¦‚æœæ—‹è½¬åˆ°äº†å³ä¸Šè§’
                    chainCoverRow = row + 1;
                    chainCoverCol = col; // ä¸‹æ–¹å°é¢
                } else if (lastTarget === 'pos1') { // å¦‚æœæ—‹è½¬åˆ°äº†å·¦ä¸Šè§’
                    chainCoverRow = row + 1;
                    chainCoverCol = col; // ä¸‹æ–¹å°é¢
                }
                
                const chainCover = this.findCoverAtPosition(chainCoverRow, chainCoverCol);
                if (chainCover && !chainCover.userData.isAnimating) {
                    // console.log(`è§¦å‘é¡ºåŠ¿è”åŠ¨: ä½ç½®(${chainCoverRow},${chainCoverCol})`);
                    setTimeout(() => {
                        this.playPinRotationAnimation(chainCover, chainLevel + 1);
                    }, 0); // æ— å»¶è¿Ÿï¼Œç«‹å³è§¦å‘
                }
            }
            
            // è§¦å‘å‘ä¸‹è”åŠ¨
            triggerDownwardChain(rotatingCover, lastTarget, chainLevel) {
                // è·å–æ—‹è½¬å°é¢å½“å‰ä½ç½®
                const row = rotatingCover.userData.row;
                const col = rotatingCover.userData.col;
                
                // æ£€æŸ¥ä¸‹æ–¹å°é¢
                const downCover = this.findCoverAtPosition(row + 1, col);
                if (downCover && !downCover.userData.isAnimating) {
                    // console.log(`è§¦å‘å‘ä¸‹è”åŠ¨: ä½ç½®(${row+1},${col})`);
                    setTimeout(() => {
                        this.playPinRotationAnimation(downCover, chainLevel + 1);
                    }, 0); // æ— å»¶è¿Ÿï¼Œç«‹å³è§¦å‘
                }
            }
            
            // è§¦å‘é£˜è½åŠ¨ç”»
            triggerFallAnimation(rotatingCover, lastTarget, chainLevel) {
                // è·å–æ—‹è½¬å°é¢å½“å‰ä½ç½®
                const row = rotatingCover.userData.row;
                const col = rotatingCover.userData.col;
                
                // æ ¹æ®lastTargetå’Œå½“å‰ä½ç½®ï¼Œç¡®å®šå¯èƒ½è§¦å‘é£˜è½åŠ¨ç”»çš„å°é¢
                let fallCoverRow, fallCoverCol;
                
                // æ ¹æ®ä¸Šä¸€æ¬¡æ—‹è½¬çš„ç›®æ ‡ä½ç½®ç¡®å®šé£˜è½å°é¢ä½ç½®
                if (lastTarget === 'pos4' || lastTarget === 'pos3') { // å¦‚æœæ—‹è½¬åˆ°äº†ä¸‹æ–¹
                    fallCoverRow = row - 1;
                    fallCoverCol = col; // ä¸Šæ–¹å°é¢
                } else if (lastTarget === 'pos2' || lastTarget === 'pos1') { // å¦‚æœæ—‹è½¬åˆ°äº†ä¸Šæ–¹
                    fallCoverRow = row;
                    fallCoverCol = col + (lastTarget === 'pos2' ? -1 : 1); // å·¦ä¾§æˆ–å³ä¾§å°é¢
                }
                
                const fallCover = this.findCoverAtPosition(fallCoverRow, fallCoverCol);
                if (fallCover && !fallCover.userData.isAnimating) {
                    // console.log(`è§¦å‘é£˜è½åŠ¨ç”»: ä½ç½®(${fallCoverRow},${fallCoverCol})`);
                    setTimeout(() => {
                        // éšæœºé€‰æ‹©é£˜è½æˆ–æ»šåŠ¨ä¸‹è½åŠ¨ç”»
                        const fallAnimationType = Math.random() < 0.5 ? 'drop' : 'rollDrop';
                        this.playAnimation(fallCover, fallAnimationType);
                    }, 0); // æ— å»¶è¿Ÿï¼Œç«‹å³è§¦å‘
                }
            }

            fadeInCover(cover) {
                const duration = 800;
                const startTime = Date.now();

                // è®¾ç½®åˆå§‹é€æ˜åº¦
                cover.material.opacity = 0;

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    cover.material.opacity = progress;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ç¡®ä¿æœ€ç»ˆé€æ˜åº¦ä¸º1
                        cover.material.opacity = 1;
                    }
                };

                animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // æ¸²æŸ“åœºæ™¯
                this.renderer.render(this.scene, this.camera);
            }

            bindEvents() {
                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    switch (e.code) {
                        case 'Escape':
                            this.exitScreensaver();
                            break;
                        case 'Space':
                            e.preventDefault();
                            this.toggleAnimations();
                            break;
                        case 'KeyR':
                            this.refreshAllCovers();
                            break;
                        case 'KeyF':
                            this.toggleFullscreen();
                            break;
                        case 'KeyH':
                        case 'Slash':
                            if (e.shiftKey && e.code === 'Slash') { // ? key
                                this.showHelp();
                            } else if (e.code === 'KeyH') {
                                this.showHelp();
                            }
                            break;
                    }
                });

                // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
                this.renderer.domElement.addEventListener('click', (event) => {
                    // å¦‚æœå¯ç”¨äº†æ¡Œé¢æ¨¡å¼ï¼Œæ£€æµ‹ä¸‰è¿å‡»
                    if (this.desktopMode) {
                        this.clickCount++;
                        
                        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                        if (this.clickTimer) {
                            clearTimeout(this.clickTimer);
                        }
                        
                        // è®¾ç½®æ–°çš„å®šæ—¶å™¨
                        this.clickTimer = setTimeout(() => {
                            // å¦‚æœæ˜¯ä¸‰è¿å‡»ï¼Œåˆ™å¤„ç†ç‚¹å‡»äº‹ä»¶
                            if (this.clickCount === 3) {
                                this.showStatusMessage('ä¸‰è¿å‡»è§¦å‘');
                                this.handleClick(event);
                            }
                            // é‡ç½®ç‚¹å‡»è®¡æ•°
                            this.clickCount = 0;
                        }, this.clickTimeout);
                    } else {
                        // éæ¡Œé¢æ¨¡å¼ï¼Œç›´æ¥å¤„ç†ç‚¹å‡»
                        this.handleClick(event);
                    }
                });

                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
                let mouseTimer;
                document.addEventListener('mousemove', () => {
                    document.body.style.cursor = 'default';
                    clearTimeout(mouseTimer);
                    mouseTimer = setTimeout(() => {
                        document.body.style.cursor = 'none';
                    }, 60000);
                });
                
                // è®¾ç½®æŒ‰é’®äº‹ä»¶
                this.settingsButton.addEventListener('click', () => {
                    this.toggleSettingsPanel();
                });
                
                // è®¾ç½®é¢æ¿å¤–éƒ¨ç‚¹å‡»å…³é—­
                document.addEventListener('click', (e) => {
                    // å¤„ç†é¢æ¿å…³é—­é€»è¾‘ - ç‚¹å‡»ä»»ä½•éè®¾ç½®é¢æ¿å’Œéè®¾ç½®æŒ‰é’®çš„åŒºåŸŸéƒ½å…³é—­é¢æ¿
                    if (this.isPanelVisible && 
                        !this.settingsPanel.contains(e.target) && 
                        !this.settingsButton.contains(e.target)) {
                        this.hideSettingsPanel();
                    }
                });
                
                // è®¾ç½®æ§ä»¶äº‹ä»¶
                this.initSettingsControls();
            }

            handleClick(event) {
                // å°„çº¿æŠ•å°„æ£€æµ‹ç‚¹å‡»çš„å°é¢
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);

                const intersects = raycaster.intersectObjects(this.covers);

                if (intersects.length > 0) {
                    const clickedCover = intersects[0].object;
                    const albumPath = clickedCover.userData.albumPath;

                    // æŸ¥æ‰¾å¯¹åº”çš„URL
                    const url = this.albumUrls[albumPath];

                    if (url) {
                        // è·å–MusicBrainz ID
                        const mbid = this.extractMusicBrainzId(url);
                        if (mbid) {
                            // è·å–å¹¶æ˜¾ç¤ºå¤–éƒ¨é“¾æ¥ï¼Œä¼ é€’ä¸“è¾‘è·¯å¾„
                            this.openExternalLinks(mbid, albumPath);
                        } else {
                            // å¦‚æœæ— æ³•æå–MBIDï¼Œåˆ™åªæ‰“å¼€åŸå§‹URL
                            window.open(url, '_blank');
                            // å¤åˆ¶URLåˆ°å‰ªè´´æ¿
                            this.copyToClipboard(url);
                        }
                        
                        // æ˜¾ç¤ºç‚¹å‡»åé¦ˆ
                        this.showClickFeedback(clickedCover);
                    }
                }
            }
            
            // ä»MusicBrainz URLä¸­æå–MBID
            extractMusicBrainzId(url) {
                // ä¾‹å¦‚ï¼šhttps://musicbrainz.org/release/59211ea4-ffd2-4ad9-9a4e-941d3148024a
                const match = url.match(/musicbrainz\.org\/release\/([a-f0-9-]+)/i);
                return match ? match[1] : null;
            }
            
            // è·å–å¤–éƒ¨é“¾æ¥ï¼ˆSpotifyå’ŒYouTube Musicï¼‰
            openExternalLinks(mbid, albumPath = null) {
                // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å·²æœ‰è¯¥MBIDçš„å¤–éƒ¨é“¾æ¥æ•°æ®
                if (this.externalLinksCache.has(mbid)) {
                    const cachedData = this.externalLinksCache.get(mbid);
                    // æ›´æ–°ç¼“å­˜æ•°æ®ä¸­çš„ä¸“è¾‘è·¯å¾„
                    if (albumPath) {
                        cachedData.albumPath = albumPath;
                    }
                    this.showLinksDialog(cachedData);
                    return;
                }
                
                // èŠ‚æµæ§åˆ¶ - ç¡®ä¿APIè°ƒç”¨é—´éš”è‡³å°‘1ç§’
                const now = Date.now();
                const timeSinceLastCall = now - this.lastApiCallTime;
                
                if (timeSinceLastCall < 1000) {
                    // å¦‚æœè·ç¦»ä¸Šæ¬¡APIè°ƒç”¨ä¸è¶³1ç§’ï¼Œå»¶è¿Ÿæ‰§è¡Œ
                    setTimeout(() => {
                        this.openExternalLinks(mbid);
                    }, 1000 - timeSinceLastCall);
                    return;
                }
                
                // æ›´æ–°æœ€åAPIè°ƒç”¨æ—¶é—´
                this.lastApiCallTime = now;
                
                // æ˜¾ç¤ºåŠ è½½ä¸­çŠ¶æ€
                this.showStatusMessage(this.texts.loadingLinks);
                
                // ä½¿ç”¨MusicBrainz APIè·å–å¤–éƒ¨é“¾æ¥
                const apiUrl = `https://musicbrainz.org/ws/2/release/${mbid}?inc=url-rels&fmt=json`;
                
                fetch(apiUrl, {
                    headers: {
                        // è®¾ç½®ç”¨æˆ·ä»£ç†ä»¥éµå¾ªMusicBrainz APIä½¿ç”¨è§„åˆ™
                        'User-Agent': 'MacScreensaver/1.0 (https://github.com/birdy/MacScreensaver)'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTPé”™è¯¯: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.relations) {
                        // æŸ¥æ‰¾Spotifyã€YouTube Musicã€Apple Musicã€iTunesã€Deezerã€Tidalã€163é“¾æ¥ä»¥åŠå…¶ä»–å¤–éƒ¨é“¾æ¥
                        let spotifyUrl = null;
                        let youtubeMusicUrl = null;
                        let appleMusicUrl = null;
                        let itunesUrl = null;
                        let deezerUrl = null;
                        let tidalUrl = null;
                        let netease163Url = null;
                        let musicBrainzUrl = null;
                        let listenBrainzUrl = null;
                        let otherLinks = [];
                        
                        // è·å–ä¸“è¾‘æ ‡é¢˜
                        const albumTitle = data.title || "ä¸“è¾‘";
                        
                        // è®¾ç½®MusicBrainzé“¾æ¥
                        musicBrainzUrl = `https://musicbrainz.org/release/${mbid}`;
                        
                        // è®¾ç½®ListenBrainzä¸“è¾‘é¡µé¢é“¾æ¥ï¼ˆåŸºäºMBIDï¼‰
                        listenBrainzUrl = `https://listenbrainz.org/release/${mbid}/`;
                        
                        for (const relation of data.relations) {
                            if (relation.url) {
                                const url = relation.url.resource;
                                
                                // æ£€æŸ¥æ˜¯å¦æ˜¯ListenBrainzé“¾æ¥
                                if (url.includes('listenbrainz.org')) {
                                    listenBrainzUrl = url; // ä¼˜å…ˆä½¿ç”¨APIè¿”å›çš„ListenBrainzé“¾æ¥
                                } else if (relation.type === 'streaming' || relation.type === 'free streaming' || relation.type === 'purchase for download') {
                                    if (url.includes('spotify.com')) {
                                        spotifyUrl = url;
                                    } else if (url.includes('music.youtube.com')) {
                                        youtubeMusicUrl = url;
                                    } else if (url.includes('music.apple.com')) {
                                        appleMusicUrl = url;
                                    } else if (url.includes('itunes.apple.com')) {
                                        itunesUrl = url;
                                    } else if (url.includes('deezer.com')) {
                                        deezerUrl = url;
                                    } else if (url.includes('tidal.com')) {
                                        tidalUrl = url;
                                    } else if (url.includes('music.163.com')) {
                                        netease163Url = url;
                                    } else {
                                        // å…¶ä»–æµåª’ä½“é“¾æ¥
                                        otherLinks.push({
                                            name: this.getServiceNameFromUrl(url),
                                            url: url
                                        });
                                    }
                                } else {
                                    // å…¶ä»–ç±»å‹çš„é“¾æ¥
                                    otherLinks.push({
                                        name: relation.type || this.getServiceNameFromUrl(url),
                                        url: url
                                    });
                                }
                            }
                        }
                        
                        // ç¼“å­˜ç»“æœ
                        const linkData = { 
                            albumTitle,
                            albumPath: albumPath, // æ·»åŠ ä¸“è¾‘è·¯å¾„
                            musicBrainzUrl, 
                            listenBrainzUrl,
                            spotifyUrl, 
                            youtubeMusicUrl,
                            appleMusicUrl,
                            itunesUrl,
                            deezerUrl,
                            tidalUrl,
                            netease163Url,
                            otherLinks
                        };
                        this.externalLinksCache.set(mbid, linkData);
                        
                        // æ˜¾ç¤ºé“¾æ¥å¯¹è¯æ¡†
                        this.showLinksDialog(linkData);
                    }
                })
                .catch(error => {
                    console.error('è·å–å¤–éƒ¨é“¾æ¥å¤±è´¥:', error);
                    this.showStatusMessage(this.texts.noExternalLinks);
                });
            }
            
            // ä»URLä¸­è·å–æœåŠ¡åç§°
            getServiceNameFromUrl(url) {
                try {
                    const hostname = new URL(url).hostname;
                    
                    // è‡ªå®šä¹‰æœåŠ¡åç§°æ˜ å°„
                    if (hostname === 'music.youtube.com') {
                        return 'Youtube Music';
                    }
                    if (hostname.includes('163')) {
                        return 'Netease Music';
                    }
                    
                    // å…¶ä»–æƒ…å†µè¿”å›åŸŸå
                    return hostname;
                } catch (e) {
                    return url;
                }
            }
            
            // æ˜¾ç¤ºé“¾æ¥å¯¹è¯æ¡†
            showLinksDialog(linkData) {
                const { albumTitle, musicBrainzUrl, listenBrainzUrl, spotifyUrl, youtubeMusicUrl, appleMusicUrl, itunesUrl, deezerUrl, tidalUrl, netease163Url, otherLinks } = linkData;
                
                // ç§»é™¤å¯èƒ½å·²å­˜åœ¨çš„å¯¹è¯æ¡†
                const existingDialog = document.getElementById('links-dialog');
                if (existingDialog) {
                    // æ¸…ç†æ—§çš„3Då±•ç¤ºå°
                    this.cleanupShowcase();
                    existingDialog.remove();
                }
                
                // åˆ›å»ºå¯¹è¯æ¡†å…ƒç´ 
                const dialog = document.createElement('div');
                dialog.id = 'links-dialog';
                dialog.className = 'links-dialog';
                
                // åˆ›å»ºå¯¹è¯æ¡†å†…å®¹
                //   <h3>${this.texts.externalLinksFor} "${albumTitle}"</h3>
                let dialogContent = `
                    <div class="dialog-header">
                      
                        <h3>${albumTitle}</h3>
                        <button class="close-button">&times;</button>
                    </div>
                    <div class="album-showcase-container">
                        <canvas id="album-showcase-canvas"></canvas>
                    </div>
                    <div class="dialog-content">
                        <ul class="links-list">
                `;
                
                // æ·»åŠ ç¬¬ä¸€è¡ŒåŒåˆ—å¸ƒå±€ï¼šMusicBrainzå’ŒListenBrainz
                if (musicBrainzUrl || listenBrainzUrl) {
                    dialogContent += `<div class="two-column-container">`;
                    
                    if (musicBrainzUrl) {
                        dialogContent += `
                            <li class="column-item icon-link">
                                <a href="#" class="link-url" data-url="${musicBrainzUrl}">
                                    <img src="https://static.metabrainz.org/MB/header-logo-1f7dc2a.svg" alt="MusicBrainz" class="link-icon" />
                                </a>
                            </li>
                        `;
                    }
                    
                    if (listenBrainzUrl) {
                        dialogContent += `
                            <li class="column-item icon-link">
                                <a href="#" class="link-url" data-url="${listenBrainzUrl}">
                                    <img src="https://listenbrainz.org/static/img/listenbrainz-logo.svg" alt="ListenBrainz" class="link-icon" />
                                </a>
                            </li>
                        `;
                    }
                    
                    dialogContent += `</div>`;
                }
                
                // æ·»åŠ Spotifyé“¾æ¥
                // éŸ³ä¹å¹³å°æ˜¾ç¤ºé¡ºåºé…ç½®ï¼ˆå¯è‡ªå®šä¹‰æ’åºï¼‰
                const platformOrder = [
                    { key: 'youtubeMusicUrl', name: 'YouTube Music', linkClass: 'youtube-music-link', iconClass: 'youtube-music-icon', iconUrl: 'https://music.youtube.com/img/favicon_144.png', iconImgClass: 'youtube-icon' },
                    { key: 'netease163Url', name: '163', linkClass: 'netease163-link', iconClass: 'netease163-icon', iconUrl: 'https://s1.music.126.net/style/favicon.ico?v20180823', iconImgClass: 'netease163-icon-img' },
                    { key: 'spotifyUrl', name: 'Spotify', linkClass: 'spotify-link', iconClass: 'spotify-icon', iconUrl: 'https://open.spotifycdn.com/cdn/images/favicon.0f31d2ea.ico', iconImgClass: 'spotify-icon-img' },
                    { key: 'appleMusicUrl', name: 'Apple Music', linkClass: 'apple-music-link', iconClass: 'apple-music-icon', iconUrl: 'https://music.apple.com/assets/favicon/favicon-180.png', iconImgClass: 'apple-icon' },
                    { key: 'itunesUrl', name: 'iTunes', linkClass: 'itunes-link', iconClass: 'itunes-icon', iconUrl: 'https://www.apple.com/v/itunes/home/l/images/overview/itunes_logo__dwjkvx332d0m_large.png', iconImgClass: 'itunes-icon-img' },
                    { key: 'deezerUrl', name: 'Deezer', linkClass: 'deezer-link', iconClass: 'deezer-icon', iconUrl: 'https://cdn-files.dzcdn.net/cache/images/common/favicon/favicon-144x144.07ae81558433f1009494.png', iconImgClass: 'deezer-icon-img' },
                    { key: 'tidalUrl', name: 'Tidal', linkClass: 'tidal-link', iconClass: 'tidal-icon', iconUrl: 'data:image/svg+xml,%3csvg%20xmlns=\'http://www.w3.org/2000/svg\'%20viewBox=\'0%200%20239.5%20159.7\'%20id=\'tidal-diamond\'%3e%3cpath%20d=\'M159.67%2039.938l-39.88%2039.88-39.88-39.88%2039.88-39.88zM159.669%20119.756l-39.88%2039.88-39.88-39.88%2039.88-39.88zM79.809%2039.912l-39.88%2039.88-39.88-39.88%2039.88-39.88zM239.505%2039.93l-39.88%2039.88-39.88-39.88%2039.88-39.88z\'/%3e%3c/svg%3e', iconImgClass: 'tidal-icon-img' }
                ];
                
                // æŒ‰é…ç½®çš„é¡ºåºæ˜¾ç¤ºéŸ³ä¹å¹³å°
                const platformLinks = { youtubeMusicUrl, netease163Url, spotifyUrl, appleMusicUrl, itunesUrl, deezerUrl, tidalUrl };
                
                for (const platform of platformOrder) {
                    const url = platformLinks[platform.key];
                    if (url) {
                        dialogContent += `
                            <li class="${platform.linkClass}">
                                <a href="#" class="link-url ${platform.iconClass}" data-url="${url}">
                                    <img src="${platform.iconUrl}" alt="${platform.name}" class="link-icon ${platform.iconImgClass}" />
                                </a>
                            </li>
                        `;
                    }
                }
                
                // æ·»åŠ å…¶ä»–é“¾æ¥
                if (otherLinks && otherLinks.length > 0) {
                    for (const link of otherLinks) {
                        dialogContent += `
                            <li>
                                <span class="link-service">${link.name}</span>
                                <a href="#" class="link-url" data-url="${link.url}">
                                    ${link.url}
                                </a>
                            </li>
                        `;
                    }
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•é“¾æ¥
                if (!musicBrainzUrl && !listenBrainzUrl && !spotifyUrl && !youtubeMusicUrl && !appleMusicUrl && !itunesUrl && !deezerUrl && !tidalUrl && !netease163Url && (!otherLinks || otherLinks.length === 0)) {
                    dialogContent += `
                        <li class="no-links">
                            ${this.texts.noLinksFound}
                        </li>
                    `;
                }
                
                dialogContent += `
                        </ul>
                    </div>
                `;
                
                // è®¾ç½®å¯¹è¯æ¡†å†…å®¹
                dialog.innerHTML = dialogContent;
                
                // æ·»åŠ æ ·å¼
                const style = document.createElement('style');
                style.textContent = `
                    .links-dialog {
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background-color: rgba(20, 20, 20, 0.8);
                        backdrop-filter: blur(10px);
                        -webkit-backdrop-filter: blur(10px);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 16px;
                        padding: 25px;
                        z-index: 1000;
                        color: #fff;
                        max-width: 80%;
                        width: 600px;
                        max-height: 80vh;
                        overflow-y: auto;
                        box-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
                        scrollbar-width: thin;
                        scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
                    }
                    
                    /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ - Webkitæµè§ˆå™¨ */
                    .links-dialog::-webkit-scrollbar {
                        width: 8px;
                    }
                    
                    .links-dialog::-webkit-scrollbar-track {
                        background: transparent;
                        border-radius: 10px;
                    }
                    
                    .links-dialog::-webkit-scrollbar-thumb {
                        background: rgba(255, 255, 255, 0.2);
                        border-radius: 10px;
                        transition: background 0.3s ease;
                    }
                    
                    .links-dialog::-webkit-scrollbar-thumb:hover {
                        background: rgba(255, 255, 255, 0.3);
                    }
                    .dialog-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 20px;
                        padding-bottom: 15px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    }
                    .dialog-header h3 {
                        margin: 0;
                        font-size: 20px;
                        font-weight: 500;
                        letter-spacing: 0.5px;
                        color: rgba(255, 255, 255, 0.95);
                    }
                    .close-button {
                        background: rgba(255, 255, 255, 0.1);
                        border: none;
                        color: #fff;
                        font-size: 20px;
                        cursor: pointer;
                        padding: 5px 10px;
                        border-radius: 50%;
                        width: 32px;
                        height: 32px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s ease;
                    }
                    .close-button:hover {
                        background: rgba(255, 255, 255, 0.2);
                    }
                    
                    /* 3Då±•ç¤ºå°å®¹å™¨æ ·å¼ - é€æ˜æ‚¬æµ®æ•ˆæœ */
                    .album-showcase-container {
                        width: 100%;
                        height: 300px;
                        position: relative;
                        background: transparent;
                        border-radius: 0;
                        margin-bottom: 20px;
                        overflow: hidden;
                        border: none;
                        box-shadow: none;
                    }
                    
                    #album-showcase-canvas {
                        width: 100% !important;
                        height: 100% !important;
                        display: block;
                        border-radius: 0;
                    }
                    .links-list {
                        list-style: none;
                        padding: 0;
                        margin: 0;
                    }
                    .links-list li {
                        padding: 15px;
                        margin-bottom: 10px;
                        border-radius: 12px;
                        background-color: rgba(255, 255, 255, 0.05);
                        display: flex;
                        flex-direction: column;
                        transition: all 0.2s ease;
                        cursor: pointer;
                    }
                    .links-list li:hover {
                        background-color: rgba(255, 255, 255, 0.1);
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    }
                    .links-list li:last-child {
                        margin-bottom: 0;
                    }
                    
                    /* åŒåˆ—å¸ƒå±€æ ·å¼ */
                    .two-column-container {
                        display: flex;
                        gap: 10px;
                        margin-bottom: 10px;
                        min-height: 80px;
                    }
                    .column-item {
                        flex: 1;
                        display: flex !important;
                        flex-direction: column !important;
                        padding: 15px;
                        border-radius: 12px;
                        background-color: rgba(255, 255, 255, 0.05);
                        transition: all 0.2s ease;
                        cursor: pointer;
                        list-style: none;
                        min-height: 80px;
                        align-items: center;
                        justify-content: center;
                    }
                    .column-item:hover {
                        background-color: rgba(255, 255, 255, 0.1);
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    }
                    
                    /* å›¾æ ‡é“¾æ¥æ ·å¼ */
                    .icon-link {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    .icon-link .link-url {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    .link-icon {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.2s ease;
                    }
                    .icon-link:hover .link-icon {
                        filter: brightness(1.1);
                        transform: scale(1.05);
                    }
                    
                    /* YouTube Music ç‰¹æ®ŠåŠ¨æ•ˆ */
                    .youtube-music-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .youtube-music-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .youtube-icon {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: youtubePulse 2s ease-in-out infinite;
                    }
                    
                    /* YouTube Music è„‰å†²åŠ¨æ•ˆ */
                    @keyframes youtubePulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(255, 0, 0, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 0, 0, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .youtube-music-link:hover .youtube-icon {
                        animation: youtubeHoverPulse 1s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 0, 0, 0.8));
                    }
                    
                    @keyframes youtubeHoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 0, 0, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(255, 0, 0, 1));
                        }
                    }
                    
                    /* èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .youtube-music-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(255, 0, 0, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: youtubeGlow 3s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes youtubeGlow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    
                    /* ç½‘æ˜“äº‘éŸ³ä¹163 ç‰¹æ®ŠåŠ¨æ•ˆ - ä»¿ç…§YouTubeçº¢è‰²ä¸»é¢˜ */
                    .netease163-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .netease163-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .netease163-icon-img {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: netease163Pulse 2s ease-in-out infinite;
                    }
                    
                    /* ç½‘æ˜“äº‘éŸ³ä¹163 è„‰å†²åŠ¨æ•ˆ */
                    @keyframes netease163Pulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(255, 0, 0, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 0, 0, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .netease163-link:hover .netease163-icon-img {
                        animation: netease163HoverPulse 1s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 0, 0, 0.8));
                    }
                    
                    @keyframes netease163HoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 0, 0, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(255, 0, 0, 1));
                        }
                    }
                    
                    /* èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .netease163-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(255, 0, 0, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: netease163Glow 3s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes netease163Glow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    
                    /* Spotify ç‰¹æ®ŠåŠ¨æ•ˆ */
                    .spotify-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .spotify-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .spotify-icon-img {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: spotifyPulse 2.5s ease-in-out infinite;
                    }
                    
                    /* Spotify è„‰å†²åŠ¨æ•ˆ */
                    @keyframes spotifyPulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(29, 185, 84, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(29, 185, 84, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .spotify-link:hover .spotify-icon-img {
                        animation: spotifyHoverPulse 1.2s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(29, 185, 84, 0.8));
                    }
                    
                    @keyframes spotifyHoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(29, 185, 84, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(29, 185, 84, 1));
                        }
                    }
                    
                    /* èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .spotify-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(29, 185, 84, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: spotifyGlow 3.5s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes spotifyGlow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    
                    /* Apple Music ç‰¹æ®ŠåŠ¨æ•ˆ */
                    .apple-music-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .apple-music-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .apple-icon {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: applePulse 3s ease-in-out infinite;
                    }
                    
                    /* Apple Music ç®€å•è„‰å†²åŠ¨æ•ˆ */
                    @keyframes applePulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(255, 45, 85, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 45, 85, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .apple-music-link:hover .apple-icon {
                        animation: appleHoverPulse 1s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 45, 85, 0.8));
                    }
                    
                    @keyframes appleHoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 45, 85, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(255, 45, 85, 1));
                        }
                    }
                    
                    /* Apple ç®€åŒ–èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .apple-music-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(255, 45, 85, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: appleGlow 3s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes appleGlow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    
                    /* Deezer ç‰¹æ®ŠåŠ¨æ•ˆ */
                    .deezer-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .deezer-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .deezer-icon-img {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: deezerPulse 2.2s ease-in-out infinite;
                    }
                    
                    /* Deezer è„‰å†²åŠ¨æ•ˆ */
                    @keyframes deezerPulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(255, 92, 51, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 92, 51, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .deezer-link:hover .deezer-icon-img {
                        animation: deezerHoverPulse 1.1s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 92, 51, 0.8));
                    }
                    
                    @keyframes deezerHoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(255, 92, 51, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(255, 92, 51, 1));
                        }
                    }
                    
                    /* èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .deezer-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(255, 92, 51, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: deezerGlow 3.2s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes deezerGlow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    
                    /* Tidal ç‰¹æ®ŠåŠ¨æ•ˆ */
                    .tidal-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .tidal-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .tidal-icon-img {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: tidalPulse 2.8s ease-in-out infinite;
                    }
                    
                    /* Tidal è„‰å†²åŠ¨æ•ˆ */
                    @keyframes tidalPulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(0, 255, 255, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(0, 255, 255, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .tidal-link:hover .tidal-icon-img {
                        animation: tidalHoverPulse 1.3s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(0, 255, 255, 0.8));
                    }
                    
                    @keyframes tidalHoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(0, 255, 255, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(0, 255, 255, 1));
                        }
                    }
                    
                    /* èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .tidal-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: tidalGlow 3.8s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes tidalGlow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    
                    /* iTunes ç‰¹æ®ŠåŠ¨æ•ˆ */
                    .itunes-link {
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .itunes-icon {
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 100%;
                        height: 100%;
                        padding: 0;
                    }
                    
                    .itunes-icon-img {
                        width: 100%;
                        height: 50px;
                        max-width: 120px;
                        object-fit: contain;
                        object-position: center;
                        filter: brightness(0.9);
                        transition: all 0.3s ease;
                        animation: itunesPulse 2.6s ease-in-out infinite;
                    }
                    
                    /* iTunes è„‰å†²åŠ¨æ•ˆ */
                    @keyframes itunesPulse {
                        0%, 100% {
                            filter: brightness(0.9) drop-shadow(0 0 5px rgba(100, 149, 237, 0.3));
                            transform: scale(1);
                        }
                        50% {
                            filter: brightness(1.1) drop-shadow(0 0 15px rgba(100, 149, 237, 0.6));
                            transform: scale(1.02);
                        }
                    }
                    
                    /* æ‚¬åœæ—¶çš„åŠ å¼ºæ•ˆæœ */
                    .itunes-link:hover .itunes-icon-img {
                        animation: itunesHoverPulse 1.2s ease-in-out infinite;
                        filter: brightness(1.2) drop-shadow(0 0 20px rgba(100, 149, 237, 0.8));
                    }
                    
                    @keyframes itunesHoverPulse {
                        0%, 100% {
                            transform: scale(1.05);
                            filter: brightness(1.2) drop-shadow(0 0 20px rgba(100, 149, 237, 0.8));
                        }
                        50% {
                            transform: scale(1.08);
                            filter: brightness(1.3) drop-shadow(0 0 25px rgba(100, 149, 237, 1));
                        }
                    }
                    
                    /* èƒŒæ™¯å…‰æ™•æ•ˆæœ */
                    .itunes-link::before {
                        content: '';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(circle, rgba(100, 149, 237, 0.1) 0%, transparent 70%);
                        transform: translate(-50%, -50%);
                        animation: itunesGlow 3.6s ease-in-out infinite;
                        z-index: -1;
                        border-radius: 12px;
                    }
                    
                    @keyframes itunesGlow {
                        0%, 100% {
                            opacity: 0.3;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        50% {
                            opacity: 0.6;
                            transform: translate(-50%, -50%) scale(1.1);
                        }
                    }
                    .link-service {
                        font-weight: 600;
                        margin-bottom: 8px;
                        color: rgba(255, 255, 255, 0.9);
                        font-size: 16px;
                    }
                    .link-url {
                        color: #64b5f6;
                        text-decoration: none;
                        word-break: break-all;
                        transition: all 0.2s ease;
                        padding: 8px 0;
                        font-size: 14px;
                    }
                    .link-url:hover {
                        color: #90caf9;
                    }
                    .no-links {
                        color: rgba(255, 255, 255, 0.6);
                        text-align: center;
                        padding: 30px 0;
                        font-style: italic;
                    }
                    .dialog-backdrop {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background-color: rgba(0, 0, 0, 0.7);
                        backdrop-filter: blur(3px);
                        -webkit-backdrop-filter: blur(3px);
                        z-index: 999;
                        animation: fadeIn 0.3s ease;
                    }
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    .links-dialog {
                        animation: slideIn 0.3s ease;
                    }
                    @keyframes slideIn {
                        from { 
                            opacity: 0;
                            transform: translate(-50%, -48%);
                        }
                        to { 
                            opacity: 1;
                            transform: translate(-50%, -50%);
                        }
                    }
                `;
                
                // åˆ›å»ºèƒŒæ™¯é®ç½©
                const backdrop = document.createElement('div');
                backdrop.className = 'dialog-backdrop';
                
                // å°†å¯¹è¯æ¡†å’Œæ ·å¼æ·»åŠ åˆ°æ–‡æ¡£
                document.body.appendChild(style);
                document.body.appendChild(backdrop);
                document.body.appendChild(dialog);
                
                // åˆå§‹åŒ–3Då±•ç¤ºå°ï¼ˆåœ¨DOMæ·»åŠ åï¼‰
                setTimeout(() => {
                    this.initializeShowcase(linkData.albumPath || linkData.albumTitle);
                }, 100);
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶å¤„ç†
                const closeButton = dialog.querySelector('.close-button');
                closeButton.addEventListener('click', () => {
                    this.cleanupShowcase();
                    dialog.remove();
                    backdrop.remove();
                    style.remove();
                });
                
                // ç‚¹å‡»èƒŒæ™¯å…³é—­å¯¹è¯æ¡†
                backdrop.addEventListener('click', () => {
                    this.cleanupShowcase();
                    dialog.remove();
                    backdrop.remove();
                    style.remove();
                });
                
                // ä¸ºæ•´ä¸ªåˆ—è¡¨é¡¹æ·»åŠ ç‚¹å‡»äº‹ä»¶
                const listItems = dialog.querySelectorAll('.links-list li');
                listItems.forEach(item => {
                    // è·³è¿‡æ²¡æœ‰é“¾æ¥çš„é¡¹ç›®ï¼ˆå¦‚"æ²¡æœ‰æ‰¾åˆ°é“¾æ¥"çš„æç¤ºï¼‰
                    if (item.classList.contains('no-links')) return;
                    
                    const link = item.querySelector('.link-url');
                    const url = link ? link.getAttribute('data-url') : null;
                    
                    // è·å–æœåŠ¡åç§°
                    let serviceName;
                    const serviceSpan = item.querySelector('.link-service');
                    if (serviceSpan) {
                        serviceName = serviceSpan.textContent;
                    } else {
                        // å¯¹äºå›¾æ ‡é“¾æ¥ï¼Œæ ¹æ®URLåˆ¤æ–­æœåŠ¡åç§°
                        if (url && url.includes('musicbrainz.org')) {
                            serviceName = 'MusicBrainz';
                        } else if (url && url.includes('listenbrainz.org')) {
                            serviceName = 'ListenBrainz';
                        } else {
                            serviceName = 'Unknown Service';
                        }
                    }
                    
                    // æ·»åŠ ç‚¹å‡»æ•ˆæœ
                    item.addEventListener('mousedown', () => {
                        item.style.transform = 'translateY(0)';
                        item.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.1)';
                    });
                    
                    item.addEventListener('mouseup', () => {
                        item.style.transform = '';
                        item.style.boxShadow = '';
                    });
                    
                    // ç‚¹å‡»æ•´ä¸ªåˆ—è¡¨é¡¹
                    item.addEventListener('click', () => {
                        if (url) {
                            this.handleLinkClick(url, serviceName, linkData);
                        }
                    });
                    
                    // ä¿ç•™é“¾æ¥çš„ç‚¹å‡»äº‹ä»¶ï¼Œä½†é˜»æ­¢å†’æ³¡ä»¥é¿å…è§¦å‘ä¸¤æ¬¡
                    if (link) {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation(); // é˜»æ­¢å†’æ³¡åˆ°åˆ—è¡¨é¡¹
                            
                            if (url) {
                                this.handleLinkClick(url, serviceName, linkData);
                            }
                        });
                    }
                });
                
                // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
                this.showStatusMessage(this.texts.externalLinksReady);
            }
            
            copyToClipboard(text) {
                // ä½¿ç”¨ç°ä»£å‰ªè´´æ¿API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæ¶ˆæ¯
                            this.showStatusMessage('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        })
                        .catch(err => {
                            console.error('æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿:', err);
                            // å›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•
                            this.fallbackCopyToClipboard(text);
                        });
                } else {
                    // å›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•
                    this.fallbackCopyToClipboard(text);
                }
            }
            
            fallbackCopyToClipboard(text) {
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶è¾“å…¥æ¡†æ¥å¤åˆ¶æ–‡æœ¬
                const tempInput = document.createElement('input');
                tempInput.style.position = 'absolute';
                tempInput.style.left = '-1000px';
                tempInput.style.top = '-1000px';
                tempInput.value = text;
                document.body.appendChild(tempInput);
                
                // é€‰æ‹©å¹¶å¤åˆ¶
                tempInput.select();
                document.execCommand('copy');
                
                // ç§»é™¤ä¸´æ—¶å…ƒç´ 
                document.body.removeChild(tempInput);
                
                // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæ¶ˆæ¯
                this.showStatusMessage('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            }

            showClickFeedback(cover) {
                // åˆ›å»ºç‚¹å‡»åé¦ˆæ•ˆæœ
                const originalScale = { ...cover.scale };
                const duration = 300;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const scale = 1 + Math.sin(progress * Math.PI) * 0.1;
                    cover.scale.set(scale, scale, scale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        cover.scale.copy(originalScale);
                    }
                };

                animate();
            }

            toggleAnimations() {
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                    this.showStatusMessage('åŠ¨ç”»å·²æš‚åœ (æŒ‰ç©ºæ ¼é”®æ¢å¤)');
                } else {
                    this.startAnimations();
                    this.showStatusMessage('åŠ¨ç”»å·²æ¢å¤');
                }
            }

            refreshAllCovers() {
                this.covers.forEach((cover, index) => {
                    setTimeout(() => {
                        const newAlbum = this.getRandomAlbum();
                        const textureLoader = new THREE.TextureLoader();
                        const newTexture = textureLoader.load(newAlbum, (loadedTexture) => {
                            this.adjustTextureForCover(loadedTexture);
                        });
                        cover.material.map = newTexture;
                        cover.material.needsUpdate = true;
                        cover.userData.albumPath = newAlbum;

                        // æ·»åŠ åˆ·æ–°åŠ¨ç”»æ•ˆæœ
                        this.fadeInCover(cover);
                    }, index * 50);
                });

                this.showStatusMessage('æ‰€æœ‰å°é¢å·²åˆ·æ–°');
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        // console.log(`æ— æ³•è¿›å…¥å…¨å±æ¨¡å¼: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            // æ·»åŠ è®¾ç½®é¢æ¿ç›¸å…³æ–¹æ³•
            toggleSettingsPanel() {
                if (this.isPanelVisible) {
                    this.hideSettingsPanel();
                } else {
                    this.showSettingsPanel();
                }
            }
            
            showSettingsPanel() {
                this.settingsPanel.style.display = 'block';
                this.isPanelVisible = true;
            }
            
            hideSettingsPanel() {
                this.settingsPanel.style.display = 'none';
                this.isPanelVisible = false;
                // éšè—é¢æ¿æ—¶ä¿å­˜è®¾ç½®
                this.saveSettings();
            }
            
            // ä¿å­˜è®¾ç½®åˆ°æœ¬åœ°å­˜å‚¨
            saveSettings() {
                try {
                    const settings = {
                        gridRows: this.gridRows,
                        gap: this.gap,
                        animationIntervalTime: this.animationIntervalTime,
                        animationWeights: this.animationWeights,
                        backgroundColor: this.scene ? this.scene.background.getHexString() : '000000',
                        desktopMode: this.desktopMode || false,
                        iframeModeEnabled: this.iframeModeEnabled || false,
                        iframeMusicBrainzModeEnabled: this.iframeMusicBrainzModeEnabled || false,
                        iframeListenBrainzModeEnabled: this.iframeListenBrainzModeEnabled || false
                    };
                    
                    localStorage.setItem('mac_screensaver_settings', JSON.stringify(settings));
                    console.log('è®¾ç½®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨:', settings);
                    
                    // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
                    this.showStatusMessage(this.texts.settingsSaved);
                } catch (error) {
                    console.warn('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
                    this.showStatusMessage(this.texts.settingsSaveFailed);
                }
            }
            
            // ä»æœ¬åœ°å­˜å‚¨åŠ è½½è®¾ç½®
            loadSettings() {
                try {
                    const savedSettings = localStorage.getItem('mac_screensaver_settings');
                    if (savedSettings) {
                        const settings = JSON.parse(savedSettings);
                        console.log('ä»æœ¬åœ°å­˜å‚¨è¯»å–åˆ°è®¾ç½®:', settings);
                        
                        // åº”ç”¨ä¿å­˜çš„è®¾ç½®
                        if (settings.gridRows !== undefined) this.gridRows = settings.gridRows;
                        if (settings.gap !== undefined) this.gap = settings.gap;
                        if (settings.animationIntervalTime !== undefined) this.animationIntervalTime = settings.animationIntervalTime;
                        if (settings.desktopMode !== undefined) this.desktopMode = settings.desktopMode;
                        if (settings.iframeModeEnabled !== undefined) this.iframeModeEnabled = settings.iframeModeEnabled;
                        if (settings.iframeMusicBrainzModeEnabled !== undefined) this.iframeMusicBrainzModeEnabled = settings.iframeMusicBrainzModeEnabled;
                        if (settings.iframeListenBrainzModeEnabled !== undefined) this.iframeListenBrainzModeEnabled = settings.iframeListenBrainzModeEnabled;
                        
                        if (settings.animationWeights) {
                            // åˆå¹¶æƒé‡è®¾ç½®ï¼Œç¡®ä¿æ‰€æœ‰é”®éƒ½å­˜åœ¨
                            this.animationWeights = {
                                ...this.animationWeights,
                                ...settings.animationWeights
                            };
                        }
                        
                        // èƒŒæ™¯é¢œè‰²ä¼šåœ¨åœºæ™¯åˆå§‹åŒ–ååº”ç”¨
                        this.savedBackgroundColor = settings.backgroundColor ? '#' + settings.backgroundColor : '#000000';
                        
                        console.log('å·²åº”ç”¨è®¾ç½®:', {
                            gridRows: this.gridRows,
                            gap: this.gap,
                            animationIntervalTime: this.animationIntervalTime,
                            animationWeights: this.animationWeights,
                            backgroundColor: this.savedBackgroundColor
                        });
                    } else {
                        console.log('æœªæ‰¾åˆ°ä¿å­˜çš„è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                    }
                } catch (error) {
                    console.warn('åŠ è½½è®¾ç½®å¤±è´¥:', error);
                }
            }
            
            // åˆå§‹åŒ–è®¾ç½®æ§ä»¶
            initSettingsControls() {
                // è¡Œæ•°è®¾ç½®
                const rowsRange = document.getElementById('rows-range');
                const rowsValue = document.getElementById('rows-value');
                rowsRange.value = this.gridRows;
                rowsValue.textContent = this.gridRows;
                
                rowsRange.addEventListener('input', () => {
                    const value = parseInt(rowsRange.value);
                    rowsValue.textContent = value;
                    this.gridRows = value;
                    this.recalculateGrid();
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                });
                
                // é—´éš™å¤§å°è®¾ç½®
                const gapRange = document.getElementById('gap-range');
                const gapValue = document.getElementById('gap-value');
                gapRange.value = this.gap;
                gapValue.textContent = this.gap;
                
                gapRange.addEventListener('input', () => {
                    const value = parseFloat(gapRange.value);
                    gapValue.textContent = value;
                    this.gap = value;
                    this.recalculateGrid();
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                });
                
                // åŠ¨ç”»é—´éš”è®¾ç½®
                const animationIntervalRange = document.getElementById('animation-interval-range');
                const animationIntervalValue = document.getElementById('animation-interval-value');
                animationIntervalRange.value = this.animationIntervalTime;
                animationIntervalValue.textContent = this.animationIntervalTime;
                
                animationIntervalRange.addEventListener('input', () => {
                    const value = parseInt(animationIntervalRange.value);
                    animationIntervalValue.textContent = value;
                    this.animationIntervalTime = value;
                    this.startAnimations(); // é‡å¯åŠ¨ç”»ä»¥åº”ç”¨æ–°é—´éš”
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                });
                
                // åŠ¨ç”»æƒé‡è®¾ç½®
                this.initWeightSlider('flip-weight', 'flip');
                this.initWeightSlider('drop-weight', 'drop');
                this.initWeightSlider('linked-drop-weight', 'linkedDrop');
                this.initWeightSlider('roll-drop-weight', 'rollDrop');
                this.initWeightSlider('pin-rotation-weight', 'pinRotation');
                this.initWeightSlider('row-roll-weight', 'rowRollDrop');
                this.initWeightSlider('row-drop-weight', 'rowDrop');
                
                // èƒŒæ™¯é¢œè‰²è®¾ç½®
                const backgroundColorPicker = document.getElementById('background-color');
                // è®¾ç½®é¢œè‰²é€‰æ‹©å™¨çš„åˆå§‹å€¼ä¸ºä¿å­˜çš„é¢œè‰²
                if (this.savedBackgroundColor) {
                    backgroundColorPicker.value = this.savedBackgroundColor;
                }
                
                backgroundColorPicker.addEventListener('input', () => {
                    this.updateBackgroundColor(backgroundColorPicker.value);
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                });
                
                // æ¡Œé¢æ¨¡å¼è®¾ç½®
                const desktopModeToggle = document.getElementById('desktop-mode-toggle');
                desktopModeToggle.checked = this.desktopMode || false;
                
                desktopModeToggle.addEventListener('change', () => {
                    this.desktopMode = desktopModeToggle.checked;
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                    
                    // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
                    if (this.desktopMode) {
                        this.showStatusMessage(this.texts.desktopModeEnabled);
                    } else {
                        this.showStatusMessage(this.texts.desktopModeDisabled);
                    }
                });
                
                // iframeæ¨¡å¼è®¾ç½®
                const iframeModeToggle = document.getElementById('iframe-mode-toggle');
                iframeModeToggle.checked = this.iframeModeEnabled || false;
                
                iframeModeToggle.addEventListener('change', () => {
                    this.iframeModeEnabled = iframeModeToggle.checked;
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                    
                    // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
                    if (this.iframeModeEnabled) {
                        this.showStatusMessage('å·²å¯ç”¨iframeæ¨¡å¼ï¼ŒéŸ³ä¹é“¾æ¥å°†åœ¨å½“å‰é¡µé¢æ‰“å¼€');
                    } else {
                        this.showStatusMessage('å·²ç¦ç”¨iframeæ¨¡å¼ï¼ŒéŸ³ä¹é“¾æ¥å°†åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€');
                    }
                });
                
                // MusicBrainz iframeæ¨¡å¼è®¾ç½®
                const iframeMusicBrainzToggle = document.getElementById('iframe-musicbrainz-toggle');
                iframeMusicBrainzToggle.checked = this.iframeMusicBrainzModeEnabled || false;
                
                iframeMusicBrainzToggle.addEventListener('change', () => {
                    this.iframeMusicBrainzModeEnabled = iframeMusicBrainzToggle.checked;
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                    
                    // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
                    if (this.iframeMusicBrainzModeEnabled) {
                        this.showStatusMessage('å·²å¯ç”¨MusicBrainz iframeæ¨¡å¼');
                    } else {
                        this.showStatusMessage('å·²ç¦ç”¨MusicBrainz iframeæ¨¡å¼');
                    }
                });
                
                // ListenBrainz iframeæ¨¡å¼è®¾ç½®
                const iframeListenBrainzToggle = document.getElementById('iframe-listenbrainz-toggle');
                iframeListenBrainzToggle.checked = this.iframeListenBrainzModeEnabled || false;
                
                iframeListenBrainzToggle.addEventListener('change', () => {
                    this.iframeListenBrainzModeEnabled = iframeListenBrainzToggle.checked;
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                    
                    // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
                    if (this.iframeListenBrainzModeEnabled) {
                        this.showStatusMessage('å·²å¯ç”¨ListenBrainz iframeæ¨¡å¼');
                    } else {
                        this.showStatusMessage('å·²ç¦ç”¨ListenBrainz iframeæ¨¡å¼');
                    }
                });
                
                // æ·»åŠ é‡ç½®æŒ‰é’®åˆ°è®¾ç½®é¢æ¿
                this.addResetButton();
            }
            
            // åˆå§‹åŒ–æƒé‡æ»‘å—
            initWeightSlider(sliderId, weightKey) {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(`${sliderId}-value`);
                
                slider.value = this.animationWeights[weightKey];
                valueDisplay.textContent = this.animationWeights[weightKey];
                
                slider.addEventListener('input', () => {
                    const value = parseFloat(slider.value);
                    valueDisplay.textContent = value;
                    this.animationWeights[weightKey] = value;
                    // å®æ—¶ä¿å­˜è®¾ç½®
                    this.saveSettings();
                });
            }
            
            // æ·»åŠ é‡ç½®æŒ‰é’®
            addResetButton() {
                const resetContainer = document.getElementById('reset-container');
                
                // åˆ›å»ºé‡ç½®æŒ‰é’®
                const resetButton = document.createElement('button');
                resetButton.textContent = this.texts.resetAllSettings;
                resetButton.style.padding = '8px 16px';
                resetButton.style.background = 'rgba(255, 59, 48, 0.8)';
                resetButton.style.color = 'white';
                resetButton.style.border = 'none';
                resetButton.style.borderRadius = '6px';
                resetButton.style.cursor = 'pointer';
                resetButton.style.fontSize = '14px';
                resetButton.style.fontWeight = '500';
                resetButton.style.transition = 'all 0.2s ease';
                
                // é¼ æ ‡æ‚¬åœæ•ˆæœ
                resetButton.addEventListener('mouseover', () => {
                    resetButton.style.background = 'rgba(255, 59, 48, 1)';
                });
                
                resetButton.addEventListener('mouseout', () => {
                    resetButton.style.background = 'rgba(255, 59, 48, 0.8)';
                });
                
                // ç‚¹å‡»äº‹ä»¶ - é‡ç½®æ‰€æœ‰è®¾ç½®
                resetButton.addEventListener('click', () => {
                    this.resetAllSettings();
                });
                
                // æ·»åŠ åˆ°å®¹å™¨
                resetContainer.appendChild(resetButton);
                
                // æ·»åŠ æ¸…é™¤ç¼“å­˜æŒ‰é’®
                const clearCacheButton = document.createElement('button');
                clearCacheButton.textContent = this.texts.clearCache;
                clearCacheButton.style.padding = '8px 16px';
                clearCacheButton.style.background = 'rgba(120, 120, 128, 0.5)';
                clearCacheButton.style.color = 'white';
                clearCacheButton.style.border = 'none';
                clearCacheButton.style.borderRadius = '6px';
                clearCacheButton.style.cursor = 'pointer';
                clearCacheButton.style.fontSize = '14px';
                clearCacheButton.style.fontWeight = '500';
                clearCacheButton.style.transition = 'all 0.2s ease';
                clearCacheButton.style.marginLeft = '10px';
                
                // é¼ æ ‡æ‚¬åœæ•ˆæœ
                clearCacheButton.addEventListener('mouseover', () => {
                    clearCacheButton.style.background = 'rgba(120, 120, 128, 0.7)';
                });
                
                clearCacheButton.addEventListener('mouseout', () => {
                    clearCacheButton.style.background = 'rgba(120, 120, 128, 0.5)';
                });
                
                // ç‚¹å‡»äº‹ä»¶ - æ¸…é™¤ç¼“å­˜
                clearCacheButton.addEventListener('click', () => {
                    this.clearAllCache();
                });
                
                // æ·»åŠ åˆ°å®¹å™¨
                resetContainer.appendChild(clearCacheButton);
            }
            
            // é‡ç½®æ‰€æœ‰è®¾ç½®åˆ°é»˜è®¤å€¼
            resetAllSettings() {
                // é»˜è®¤è®¾ç½®
                this.gridRows = 6;
                this.gap = 0;
                this.animationIntervalTime = 3000;
                this.animationWeights = {
                    flip: 15,
                    drop: 15,
                    linkedDrop: 15,
                    rollDrop: 15,
                    pinRotation: 15,
                    rowRollDrop: 12.5,
                    rowDrop: 12.5
                };
                
                // é‡ç½®æ¡Œé¢æ¨¡å¼
                this.desktopMode = false;
                
                // æ›´æ–°UIæ§ä»¶
                document.getElementById('rows-range').value = this.gridRows;
                document.getElementById('rows-value').textContent = this.gridRows;
                document.getElementById('desktop-mode-toggle').checked = false;
                
                document.getElementById('gap-range').value = this.gap;
                document.getElementById('gap-value').textContent = this.gap;
                
                document.getElementById('animation-interval-range').value = this.animationIntervalTime;
                document.getElementById('animation-interval-value').textContent = this.animationIntervalTime;
                
                document.getElementById('background-color').value = '#000000';
                
                // æ›´æ–°æƒé‡æ»‘å—
                this.updateWeightSlider('flip-weight', 'flip');
                this.updateWeightSlider('drop-weight', 'drop');
                this.updateWeightSlider('linked-drop-weight', 'linkedDrop');
                this.updateWeightSlider('roll-drop-weight', 'rollDrop');
                this.updateWeightSlider('pin-rotation-weight', 'pinRotation');
                this.updateWeightSlider('row-roll-weight', 'rowRollDrop');
                this.updateWeightSlider('row-drop-weight', 'rowDrop');
                
                // åº”ç”¨è®¾ç½®
                this.updateBackgroundColor('#000000');
                this.recalculateGrid();
                this.startAnimations();
                
                // æ¸…é™¤æœ¬åœ°å­˜å‚¨ä¸­çš„è®¾ç½®
                localStorage.removeItem('mac_screensaver_settings');
                
                this.showStatusMessage(this.texts.allSettingsReset);
            }
            
            // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
            clearAllCache() {
                // æ¸…é™¤å°é¢ç¼“å­˜
                localStorage.removeItem('musicbrainz_cover_cache');
                // æ¸…é™¤ä¸“è¾‘åˆ—è¡¨ç¼“å­˜
                localStorage.removeItem('musicbrainz_albums_cache');
                // æ¸…é™¤è®¾ç½®ç¼“å­˜
                localStorage.removeItem('mac_screensaver_settings');
                
                this.showStatusMessage(this.texts.allCacheCleared);
                
                // 3ç§’ååˆ·æ–°é¡µé¢
                setTimeout(() => {
                    window.location.reload();
                }, 3000);
            }
            
            // æ›´æ–°æƒé‡æ»‘å—å€¼
            updateWeightSlider(sliderId, weightKey) {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(`${sliderId}-value`);
                
                slider.value = this.animationWeights[weightKey];
                valueDisplay.textContent = this.animationWeights[weightKey];
            }
            
            // æ›´æ–°èƒŒæ™¯é¢œè‰²
            updateBackgroundColor(color) {
                this.scene.background = new THREE.Color(color);
            }
            
            showHelp() {
                const helpDiv = document.createElement('div');
                helpDiv.className = 'help-overlay';
                helpDiv.style.display = 'flex';

                helpDiv.innerHTML = `
                    <div style="max-width: 600px; padding: 40px; background: rgba(20, 20, 20, 0.95); border-radius: 20px; text-align: left;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #fff;">Macä¸“è¾‘å°é¢å±ä¿ - Three.jsç‰ˆæœ¬</h3>
                        <div style="margin-bottom: 15px;"><strong>é¼ æ ‡æ“ä½œï¼š</strong></div>
                        <div style="margin-left: 20px; margin-bottom: 15px;">
                            â€¢ ç‚¹å‡»å°é¢ï¼šè·³è½¬åˆ°éŸ³ä¹å¹³å°æœç´¢å¹¶å¤åˆ¶é“¾æ¥åˆ°å‰ªè´´æ¿<br>
                            â€¢ å³ä¸Šè§’è®¾ç½®ï¼šè°ƒæ•´ç½‘æ ¼ã€åŠ¨ç”»å’Œå¤–è§‚<br>
                            â€¢ æ¡Œé¢æ¨¡å¼ï¼šå¯ç”¨ååªå“åº”ä¸‰è¿å‡»å·¦é”®ï¼Œé€‚åˆä½œä¸ºæ¡Œé¢å£çº¸ä½¿ç”¨
                        </div>
                        <div style="margin-bottom: 15px;"><strong>é”®ç›˜å¿«æ·é”®ï¼š</strong></div>
                        <div style="margin-left: 20px; margin-bottom: 15px;">
                            â€¢ <code>ESC</code> - é€€å‡ºå±ä¿<br>
                            â€¢ <code>ç©ºæ ¼</code> - æš‚åœ/æ¢å¤åŠ¨ç”»<br>
                            â€¢ <code>R</code> - åˆ·æ–°æ‰€æœ‰å°é¢<br>
                            â€¢ <code>F</code> - åˆ‡æ¢å…¨å±æ¨¡å¼<br>
                            â€¢ <code>H</code> æˆ– <code>?</code> - æ˜¾ç¤ºæ­¤å¸®åŠ©
                        </div>
                        <div style="margin-bottom: 15px;"><strong>åŠ¨ç”»æ•ˆæœï¼š</strong></div>
                        <div style="margin-left: 20px; margin-bottom: 20px;">
                            â€¢ ç¿»è½¬æ›¿æ¢ï¼šå°é¢3Dç¿»è½¬æ˜¾ç¤ºæ–°ä¸“è¾‘<br>
                            â€¢ æ‰è½åŠ¨ç”»ï¼šå°é¢3Dæ‰è½æ•ˆæœ<br>
                            â€¢ é€æ ¼ç¿»æ»šï¼šå°é¢æ²¿ç½‘æ ¼é€æ ¼å‘ä¸‹ç¿»æ»š<br>
                            â€¢ ç§»åŠ¨åŠ¨ç”»ï¼šå°é¢åœ¨3Dç©ºé—´ä¸­ç§»åŠ¨<br>
                            â€¢ å›¾é’‰æ—‹è½¬ï¼šå°é¢ç»•å›¾é’‰æ—‹è½¬åˆ°æ–°ä½ç½®
                        </div>
                        <div style="text-align: center; margin-top: 30px;">
                            <button onclick="this.parentElement.parentElement.remove()"
                                    style="padding: 10px 20px; background: #007AFF; color: white; border: none; border-radius: 10px; cursor: pointer;">
                                å…³é—­å¸®åŠ©
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(helpDiv);

                // ç‚¹å‡»èƒŒæ™¯å…³é—­
                helpDiv.addEventListener('click', (e) => {
                    if (e.target === helpDiv) {
                        helpDiv.remove();
                    }
                });
            }

            showStatusMessage(message) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'status-message';
                statusDiv.textContent = message;
                document.body.appendChild(statusDiv);

                // æ˜¾ç¤ºåŠ¨ç”»
                setTimeout(() => {
                    statusDiv.style.opacity = '1';
                }, 10);

                // è‡ªåŠ¨éšè—
                setTimeout(() => {
                    statusDiv.style.opacity = '0';
                    setTimeout(() => {
                        if (statusDiv.parentNode) {
                            statusDiv.parentNode.removeChild(statusDiv);
                        }
                    }, 300);
                }, 2000);
            }

            exitScreensaver() {
                // å¯ä»¥æ·»åŠ é€€å‡ºé€»è¾‘ï¼Œæ¯”å¦‚è·³è½¬åˆ°å…¶ä»–é¡µé¢
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                this.showStatusMessage(this.texts.helpEsc);
            }

            hideLoading() {
                this.loading.style.display = 'none';
            }

            showError(message) {
                // éšè—åŠ è½½åŠ¨ç”»
                const spinner = this.loading.querySelector('.loading-spinner');
                if (spinner) {
                    spinner.style.display = 'none';
                }

                // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                if (this.loadingText) {
                    this.loadingText.innerHTML = `<div style="color: #ff6b6b;">${message}</div>`;
                }

                // æ¸…ç©ºè¿›åº¦ä¿¡æ¯
                if (this.loadingProgress) {
                    this.loadingProgress.textContent = '';
                }
            }

            // ===== iframeæ’­æ”¾å™¨ç›¸å…³æ–¹æ³• =====
            
            // åˆå§‹åŒ–iframeæ’­æ”¾å™¨
            initIframePlayer() {
                try {
                    console.log('åˆå§‹åŒ–iframeæ’­æ”¾å™¨...');
                    
                    // åˆå§‹åŒ–iframe 3Då±•ç¤ºå°
                    this.initIframeShowcase();
                    
                    // ç»‘å®šiframeæ§åˆ¶æŒ‰é’®äº‹ä»¶
                    this.bindIframeEvents();
                    
                    console.log('iframeæ’­æ”¾å™¨åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('iframeæ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥:', error);
                }
            }
            
            // åˆå§‹åŒ–iframe 3Då±•ç¤ºå°
            initIframeShowcase() {
                try {
                    const canvas = this.iframeShowcaseCanvas;
                    if (!canvas) return;
                    
                    // åˆ›å»ºåœºæ™¯
                    this.iframeShowcaseScene = new THREE.Scene();
                    
                    // åˆ›å»ºç›¸æœº
                    const aspect = 1; // æ­£æ–¹å½¢ç”»å¸ƒ
                    this.iframeShowcaseCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                    this.iframeShowcaseCamera.position.set(0, 0, 2);
                    
                    // åˆ›å»ºæ¸²æŸ“å™¨
                    this.iframeShowcaseRenderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        alpha: true, // å¯ç”¨é€æ˜åº¦
                        antialias: true
                    });
                    this.iframeShowcaseRenderer.setSize(40, 40);
                    this.iframeShowcaseRenderer.setClearColor(0x000000, 0); // å®Œå…¨é€æ˜èƒŒæ™¯
                    
                    // æ·»åŠ ç¯å…‰
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    this.iframeShowcaseScene.add(ambientLight);
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(1, 1, 1);
                    this.iframeShowcaseScene.add(directionalLight);
                    
                    console.log('iframe 3Då±•ç¤ºå°åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('iframe 3Då±•ç¤ºå°åˆå§‹åŒ–å¤±è´¥:', error);
                }
            }
            
            // åˆå§‹åŒ–æ¨±èŠ±é£˜è½åŠ¨ç”»
            initCherryBlossomAnimation() {
                try {
                    // å…ˆåœæ­¢ä¹‹å‰çš„åŠ¨ç”»
                    this.stopCherryBlossomAnimation();

                    // ç­‰å¾…jQueryåŠ è½½å®Œæˆååˆå§‹åŒ–æ¨±èŠ±é£˜è½åŠ¨ç”»
                    if (typeof $ !== 'undefined' && typeof RENDERER !== 'undefined') {
                        // ç¡®ä¿å®¹å™¨å­˜åœ¨
                        const container = document.getElementById('jsi-cherry-container');
                        if (container) {
                            // æ¸…ç©ºå®¹å™¨å†…å®¹
                            container.innerHTML = '';
                            // é‡æ–°åˆå§‹åŒ–
                            RENDERER.init();
                            console.log('æ¨±èŠ±é£˜è½åŠ¨ç”»åˆå§‹åŒ–å®Œæˆ');
                        } else {
                            console.warn('æ¨±èŠ±é£˜è½åŠ¨ç”»å®¹å™¨æœªæ‰¾åˆ°');
                        }
                    } else {
                        console.warn('jQueryæˆ–æ¨±èŠ±é£˜è½åŠ¨ç”»è„šæœ¬æœªåŠ è½½');
                        // å»¶è¿Ÿé‡è¯•
                        setTimeout(() => {
                            this.initCherryBlossomAnimation();
                        }, 100);
                    }
                } catch (error) {
                    console.error('æ¨±èŠ±é£˜è½åŠ¨ç”»åˆå§‹åŒ–å¤±è´¥:', error);
                }
            }

            // åœæ­¢æ¨±èŠ±é£˜è½åŠ¨ç”»
            stopCherryBlossomAnimation() {
                try {
                    if (typeof RENDERER !== 'undefined') {
                        // è°ƒç”¨RENDERERçš„stopæ–¹æ³•
                        RENDERER.stop();

                        // æ¸…ç©ºå®¹å™¨
                        const container = document.getElementById('jsi-cherry-container');
                        if (container) {
                            container.innerHTML = '';
                        }
                        console.log('æ¨±èŠ±é£˜è½åŠ¨ç”»å·²åœæ­¢');
                    }
                } catch (error) {
                    console.error('åœæ­¢æ¨±èŠ±é£˜è½åŠ¨ç”»å¤±è´¥:', error);
                }
            }
            

            

            
            // ç»‘å®šiframeäº‹ä»¶
            bindIframeEvents() {
                // å›ºå®šæŒ‰é’®
                this.iframePinBtn.addEventListener('click', () => {
                    this.toggleIframePin();
                });
                
                // å±•å¼€/æ”¶ç¼©æŒ‰é’®
                this.iframeExpandBtn.addEventListener('click', () => {
                    this.toggleIframeExpand();
                });
                
                // å…³é—­æŒ‰é’®
                this.iframeCloseBtn.addEventListener('click', () => {
                    this.closeIframePlayer();
                });
                
                // é¼ æ ‡è¿›å…¥/ç¦»å¼€äº‹ä»¶
                this.iframePlayer.addEventListener('mouseenter', () => {
                    this.onIframeMouseEnter();
                });
                
                this.iframePlayer.addEventListener('mouseleave', () => {
                    this.onIframeMouseLeave();
                });
            }
            
            // æ‰“å¼€iframeæ’­æ”¾å™¨
            openIframePlayer(url, albumData) {
                console.log('æ‰“å¼€iframeæ’­æ”¾å™¨:', url, albumData);
                
                this.currentIframeUrl = url;
                this.currentAlbumData = albumData;
                
                // æ›´æ–°æ ‡é¢˜å’ŒæœåŠ¡ä¿¡æ¯
                this.iframeTitle.textContent = albumData.albumTitle || 'æœªçŸ¥ä¸“è¾‘';
                this.iframeService.textContent = this.getServiceNameFromUrl(url);
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                this.iframeLoading.style.display = 'block';
                this.iframeEmbed.style.display = 'none';
                
                // æ˜¾ç¤ºæ’­æ”¾å™¨
                this.iframePlayer.style.display = 'block';
                setTimeout(() => {
                    this.iframePlayer.classList.add('expanded');
                    this.isIframeExpanded = true;
                    this.iframeExpandBtn.textContent = 'â¬‡ï¸';

                    // åˆå§‹åŒ–æ¨±èŠ±é£˜è½åŠ¨ç”»
                    this.initCherryBlossomAnimation();
                }, 100);

                // æ›´æ–°å°é¢å±•ç¤º
                this.updateIframeShowcase(albumData);
                
                // åŠ è½½iframeå†…å®¹
                this.loadIframeContent(url);
            }
            
            // åŠ è½½iframeå†…å®¹
            loadIframeContent(url) {
                const iframe = this.iframeEmbed;
                
                // è½¬æ¢URLä¸ºiframeå…¼å®¹æ ¼å¼
                const embedUrl = this.convertToEmbedUrl(url);
                console.log('åŸå§‹URL:', url);
                console.log('è½¬æ¢åçš„URL:', embedUrl);
                
                // æ¸…ç†ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
                iframe.onload = null;
                iframe.onerror = null;
                
                // è®¾ç½®åŠ è½½è¶…æ—¶
                const loadTimeout = setTimeout(() => {
                    console.warn('iframeåŠ è½½è¶…æ—¶');
                    this.iframeLoading.innerHTML = `
                        <div style="color: #ff9800;">
                            <div>åŠ è½½è¶…æ—¶</div>
                            <div style="font-size: 12px; margin-top: 5px;">
                                <a href="${url}" target="_blank" style="color: #4a9eff;">åœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€</a>
                            </div>
                        </div>
                    `;
                }, 10000); // 10ç§’è¶…æ—¶
                
                iframe.onload = () => {
                    console.log('iframeå†…å®¹åŠ è½½å®Œæˆ');
                    clearTimeout(loadTimeout);
                    this.iframeLoading.style.display = 'none';
                    iframe.style.display = 'block';
                };
                
                iframe.onerror = (error) => {
                    console.error('iframeå†…å®¹åŠ è½½å¤±è´¥:', error);
                    clearTimeout(loadTimeout);
                    this.iframeLoading.innerHTML = `
                        <div style="color: #ff6b6b;">
                            <div>åŠ è½½å¤±è´¥</div>
                            <div style="font-size: 12px; margin-top: 5px;">
                                <a href="${url}" target="_blank" style="color: #4a9eff;">åœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€</a>
                            </div>
                        </div>
                    `;
                };
                
                // å…ˆé‡ç½®iframe
                iframe.src = 'about:blank';
                
                // ç¨ç­‰ä¸€ä¸‹å†è®¾ç½®çœŸæ­£çš„URL
                setTimeout(() => {
                    iframe.src = embedUrl;
                    console.log('è®¾ç½®iframe src:', embedUrl);
                }, 100);
            }
            
            // æ›´æ–°iframeå°é¢å±•ç¤º
            updateIframeShowcase(albumData) {
                if (!this.iframeShowcaseScene || !this.iframeShowcaseCamera || !this.iframeShowcaseRenderer) return;
                
                // æ¸…ç†æ—§çš„å°é¢
                if (this.iframeShowcaseCover) {
                    this.iframeShowcaseScene.remove(this.iframeShowcaseCover);
                    if (this.iframeShowcaseCover.material.map) {
                        this.iframeShowcaseCover.material.map.dispose();
                    }
                    this.iframeShowcaseCover.material.dispose();
                    this.iframeShowcaseCover.geometry.dispose();
                }
                
                // åˆ›å»ºæ–°çš„å°é¢
                const textureLoader = new THREE.TextureLoader();
                const albumPath = albumData.albumPath || `bg/${albumData.albumTitle}.jpg`;
                
                textureLoader.load(albumPath, (texture) => {
                    // åˆ›å»ºåœ†å½¢å‡ ä½•ä½“è€Œä¸æ˜¯æ­£æ–¹å½¢ï¼Œå¤§å°x2
                    const geometry = new THREE.CircleGeometry(1.0, 32); // åŠå¾„1.0ï¼ˆåŸæ¥0.5çš„2å€ï¼‰ï¼Œ32ä¸ªåˆ†æ®µä½¿åœ†å½¢æ›´å…‰æ»‘
                    const material = new THREE.MeshLambertMaterial({ map: texture });
                    
                    this.iframeShowcaseCover = new THREE.Mesh(geometry, material);
                    this.iframeShowcaseScene.add(this.iframeShowcaseCover);
                    
                    // å¼€å§‹æ¸²æŸ“å¾ªç¯
                    this.startIframeShowcaseAnimation();
                }, undefined, (error) => {
                    console.warn('åŠ è½½iframeå°é¢å¤±è´¥:', error);
                });
            }
            
            // å¼€å§‹iframeå±•ç¤ºå°åŠ¨ç”»
            startIframeShowcaseAnimation() {
                if (this.iframeShowcaseAnimationId) {
                    cancelAnimationFrame(this.iframeShowcaseAnimationId);
                }
                
                const animate = () => {
                    this.iframeShowcaseAnimationId = requestAnimationFrame(animate);
                    
                    // æ—‹è½¬å°é¢ - æ”¹ä¸ºZè½´æ—‹è½¬ï¼ˆåƒé»‘èƒ¶å”±ç‰‡ä¸€æ ·å¹³é¢å†…æ—‹è½¬ï¼‰ï¼Œå‘å³æ—‹è½¬
                    if (this.iframeShowcaseCover) {
                        this.iframeShowcaseCover.rotation.z -= 0.01; // è´Ÿå€¼è¡¨ç¤ºå‘å³æ—‹è½¬
                    }
                    

                    
                    // æ¸²æŸ“å±•ç¤ºå°
                    if (this.iframeShowcaseRenderer && this.iframeShowcaseScene && this.iframeShowcaseCamera) {
                        this.iframeShowcaseRenderer.render(this.iframeShowcaseScene, this.iframeShowcaseCamera);
                    }
                };
                
                animate();
            }
            
            // åœæ­¢iframeå±•ç¤ºå°åŠ¨ç”»
            stopIframeShowcaseAnimation() {
                if (this.iframeShowcaseAnimationId) {
                    cancelAnimationFrame(this.iframeShowcaseAnimationId);
                    this.iframeShowcaseAnimationId = null;
                }
            }
            
            // åˆ‡æ¢iframeå›ºå®šçŠ¶æ€
            toggleIframePin() {
                this.isIframePinned = !this.isIframePinned;
                this.iframePinBtn.classList.toggle('active', this.isIframePinned);
                
                if (this.isIframePinned) {
                    this.iframePinBtn.textContent = 'ğŸ“';
                    console.log('iframeå·²å›ºå®š');
                } else {
                    this.iframePinBtn.textContent = 'ğŸ“Œ';
                    console.log('iframeå·²å–æ¶ˆå›ºå®š');
                }
            }
            
            // åˆ‡æ¢iframeå±•å¼€çŠ¶æ€
            toggleIframeExpand() {
                if (this.isIframeExpanded) {
                    this.collapseIframePlayer();
                } else {
                    this.expandIframePlayer();
                }
            }
            
            // å±•å¼€iframeæ’­æ”¾å™¨
            expandIframePlayer() {
                this.iframePlayer.classList.remove('collapsed');
                this.iframePlayer.classList.add('expanded');
                this.isIframeExpanded = true;
                this.iframeExpandBtn.textContent = 'â¬‡ï¸';
                console.log('iframeæ’­æ”¾å™¨å·²å±•å¼€');
            }
            
            // æ”¶ç¼©iframeæ’­æ”¾å™¨
            collapseIframePlayer() {
                this.iframePlayer.classList.remove('expanded');
                this.iframePlayer.classList.add('collapsed');
                this.isIframeExpanded = false;
                this.iframeExpandBtn.textContent = 'â¬†ï¸';
                console.log('iframeæ’­æ”¾å™¨å·²æ”¶ç¼©');
            }
            
            // æµ‹è¯•163é“¾æ¥åŠŸèƒ½ - ç”¨äºè°ƒè¯•å’Œæ¼”ç¤º
            test163Link() {
                console.log('æµ‹è¯•163é“¾æ¥åŠŸèƒ½');
                const testLinkData = {
                    albumTitle: 'æµ‹è¯•ä¸“è¾‘ - ç½‘æ˜“äº‘éŸ³ä¹163',
                    albumPath: 'test/163',
                    musicBrainzUrl: null,
                    listenBrainzUrl: null,
                    spotifyUrl: null,
                    youtubeMusicUrl: null,
                    appleMusicUrl: null,
                    itunesUrl: null,
                    deezerUrl: null,
                    tidalUrl: null,
                    netease163Url: 'https://music.163.com/outchain/player?type=1&id=73257118&auto=1&height=430',
                    otherLinks: []
                };
                
                this.showLinksDialog(testLinkData);
            }
            
            // å…³é—­iframeæ’­æ”¾å™¨
            closeIframePlayer() {
                console.log('å…³é—­iframeæ’­æ”¾å™¨');

                // åœæ­¢åŠ¨ç”»
                this.stopIframeShowcaseAnimation();

                // åœæ­¢æ¨±èŠ±é£˜è½åŠ¨ç”»
                this.stopCherryBlossomAnimation();

                // æ¸…ç†iframeå†…å®¹
                this.iframeEmbed.src = '';
                
                // éšè—æ’­æ”¾å™¨
                this.iframePlayer.classList.remove('expanded', 'collapsed');
                setTimeout(() => {
                    this.iframePlayer.style.display = 'none';
                }, 400);
                
                // é‡ç½®çŠ¶æ€
                this.isIframeExpanded = false;
                this.isIframePinned = false;
                this.iframePinBtn.classList.remove('active');
                this.iframePinBtn.textContent = 'ğŸ“Œ';
                this.iframeExpandBtn.textContent = 'â¬‡ï¸';
                
                // æ¸…ç†å˜é‡
                this.currentIframeUrl = null;
                this.currentAlbumData = null;
            }
            
            // é¼ æ ‡è¿›å…¥iframe
            onIframeMouseEnter() {
                if (this.iframeMouseLeaveTimer) {
                    clearTimeout(this.iframeMouseLeaveTimer);
                    this.iframeMouseLeaveTimer = null;
                }
                
                // å¦‚æœå½“å‰æ˜¯æ”¶ç¼©çŠ¶æ€ä¸”æœªå›ºå®šï¼Œåˆ™å±•å¼€
                if (!this.isIframeExpanded && !this.isIframePinned) {
                    this.expandIframePlayer();
                }
            }
            
            // é¼ æ ‡ç¦»å¼€iframe
            onIframeMouseLeave() {
                // å¦‚æœæœªå›ºå®šï¼Œè®¾ç½®å»¶è¿Ÿæ”¶ç¼©
                if (!this.isIframePinned) {
                    this.iframeMouseLeaveTimer = setTimeout(() => {
                        if (this.isIframeExpanded) {
                            this.collapseIframePlayer();
                        }
                    }, 1000); // 1ç§’åæ”¶ç¼©
                }
            }

            // å¤„ç†é“¾æ¥ç‚¹å‡» - æ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦ä½¿ç”¨iframe
            handleLinkClick(url, serviceName, albumData) {
                console.log('å¤„ç†é“¾æ¥ç‚¹å‡»:', url, serviceName, this.iframeModeEnabled);
                
                // å¤åˆ¶åˆ°å‰ªè´´æ¿
                this.copyToClipboard(url);
                
                // æ˜¾ç¤ºæç¤º
                this.showStatusMessage(this.formatText('linkCopied', {
                    service: serviceName
                }));
                
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä½¿ç”¨iframeæ¨¡å¼
                let shouldUseIframe = false;
                
                if (url.includes('musicbrainz.org')) {
                    shouldUseIframe = this.iframeMusicBrainzModeEnabled;
                } else if (url.includes('listenbrainz.org')) {
                    shouldUseIframe = this.iframeListenBrainzModeEnabled;
                } else {
                    // å…¶ä»–éŸ³ä¹æµåª’ä½“æœåŠ¡
                    const isMusicService = this.isMusicStreamingService(url);
                    shouldUseIframe = this.iframeModeEnabled && isMusicService;
                }
                
                if (shouldUseIframe) {
                    // ä½¿ç”¨iframeæ¨¡å¼æ‰“å¼€
                    this.openIframePlayer(url, albumData);
                } else {
                    // åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€
                    window.open(url, '_blank');
                }
            }

            // åˆ¤æ–­æ˜¯å¦ä¸ºéŸ³ä¹æµåª’ä½“æœåŠ¡
            isMusicStreamingService(url) {
                const musicServices = [
                    'spotify.com',
                    'music.youtube.com',
                    'music.apple.com',
                    'itunes.apple.com',
                    'deezer.com',
                    'tidal.com',
                    'music.163.com',
                    'soundcloud.com',
                    'bandcamp.com',
                    'music.amazon.com'
                ];
                
                return musicServices.some(service => url.includes(service));
            }

            // è½¬æ¢URLä¸ºiframeå…¼å®¹çš„embedæ ¼å¼
            convertToEmbedUrl(url) {
                try {
                    console.log('å¼€å§‹è½¬æ¢URL:', url);
                    
                    // Spotifyé“¾æ¥è½¬æ¢
                    if (url.includes('open.spotify.com')) {
                        console.log('æ£€æµ‹åˆ°Spotifyé“¾æ¥');
                        
                        // ç§»é™¤æŸ¥è¯¢å‚æ•°
                        const cleanUrl = url.split('?')[0];
                        console.log('æ¸…ç†åçš„URL:', cleanUrl);
                        
                        // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯embedæ ¼å¼
                        if (cleanUrl.includes('/embed/')) {
                            console.log('å·²ç»æ˜¯embedæ ¼å¼');
                            return url;
                        }
                        
                        // è½¬æ¢ä¸ºembedæ ¼å¼
                        const embedUrl = cleanUrl.replace('open.spotify.com/', 'open.spotify.com/embed/');
                        console.log('è½¬æ¢ä¸ºembedæ ¼å¼:', embedUrl);
                        
                        // æ·»åŠ å¿…è¦çš„æŸ¥è¯¢å‚æ•°
                        const finalUrl = embedUrl + '?utm_source=generator';
                        console.log('æœ€ç»ˆURL:', finalUrl);
                        return finalUrl;
                    }
                    
                    // YouTube Musicé“¾æ¥è½¬æ¢
                    if (url.includes('music.youtube.com')) {
                        console.log('æ£€æµ‹åˆ°YouTube Musicé“¾æ¥ï¼Œæš‚æ—¶è¿”å›åŸURL');
                        return url;
                    }
                    
                    // ç½‘æ˜“äº‘éŸ³ä¹163é“¾æ¥è½¬æ¢
                    if (url.includes('music.163.com')) {
                        console.log('æ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹163é“¾æ¥');
                        
                        // ä»URLä¸­æå–ID
                        // ä¾‹å¦‚ï¼šhttps://music.163.com/outchain/player?type=1&id=73257118&auto=1&height=430
                        const idMatch = url.match(/[?&]id=(\d+)/);
                        
                        if (idMatch && idMatch[1]) {
                            const musicId = idMatch[1];
                            const convertedUrl = `https://notion.busiyi.world/music-player/?server=netease&type=album&id=${musicId}&list-max-height=96`;
                            console.log('163é“¾æ¥è½¬æ¢æˆåŠŸ:', convertedUrl);
                            return convertedUrl;
                        } else {
                            console.warn('æ— æ³•ä»163é“¾æ¥ä¸­æå–IDï¼Œè¿”å›åŸURL');
                            return url;
                        }
                    }
                    
                    // å…¶ä»–æœåŠ¡æš‚æ—¶è¿”å›åŸURL
                    console.log('å…¶ä»–æœåŠ¡ï¼Œè¿”å›åŸURL');
                    return url;
                    
                } catch (error) {
                    console.error('URLè½¬æ¢å¤±è´¥:', error);
                    return url;
                }
            }
        }

        // å¯åŠ¨å±ä¿
        window.addEventListener('DOMContentLoaded', () => {
            window.screensaver = new ThreeJSScreensaver();
            
            // æš´éœ²æµ‹è¯•æ–¹æ³•åˆ°å…¨å±€ï¼Œæ–¹ä¾¿è°ƒè¯•
            window.test163 = () => window.screensaver.test163Link();
            
            console.log('ç½‘æ˜“äº‘éŸ³ä¹163æ”¯æŒå·²æ·»åŠ ï¼');
            console.log('æµ‹è¯•æ–¹æ³•ï¼šåœ¨æ§åˆ¶å°è¾“å…¥ test163() æ¥æµ‹è¯•163é“¾æ¥åŠŸèƒ½');
        });
    </script>
</body>
</html>
